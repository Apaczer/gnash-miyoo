/**

\page IO Module IO: Asynchronous I/O

	The ACT environment has unique interface requirements for the control of asynchronous I/O.
	The ordinary stream abstraction, for example, assumes full information about data availability,
		which is either present or at end-of-file.
	For an asynchronous stream, however, there's a third state of no current information,
		frequently indicated by the return value "would block".
	This distinction is at the core of the present module.

\section s_IO_Elements Elements of the IO Module
	- \b Devices. 
		The central abstractions of this module are the unidirectional Source and Sink classes which combine to form a Device.
		A Device instance, in this module, refers to a connection (which might be used as a stream),
			rather than to any specific hardware device.
		In other words, it's a view of a device ignoring multiplexing, 
			as if its user had exclusive access to it and were using it for just one connection.
		These are abstract interface classes, rather than simply model specifications, 
			in order to allow a Device user to operate with multiple Devices.
		The immediate motivation for this choice is to enable automatic test of Device users.
		A string device is present for this purpose.

	- \b Device Generators and \b Behaviors.
		Writing an internet server entails requests and responses over a network connection.
		This module splits these into two concerns: generators and behaviors.
		A generator encapsulates a facility that makes new connections, such as a server socket listening on a well-known port.
		A behavior is the request/response interaction independent of the kind of I/O present.
		A generator is a producer of Device instances; a behavior is their consumer.
		Combining a generator and a kind of behavior yields a task generator that can initialize a service (see ACT::Service).

	- \b Buffers.
		The essence of efficient network I/O uses two elements: block interface rather than character interface,
			and a zero-copy discipline that necessitates scatter-gather primitives.
		The present buffer combines a common way of interacting with memory chopped up into segments,
			each of which is a single continguous block of memory.		
		There are two ways of viewing this memory: either as a sequence of segments or as a sequence of characters.
		Buffers provide iterators to both.

	- \b Streams.
		A stream, in the present model, is primarily a means of using buffered input.
		The present stream abstraction does not hide the segment-sequence underpinnings,
			but rather handles issues arising from asynchronous control,
			particular obtaining new input for an incomplete scan or parse.
	
 */
