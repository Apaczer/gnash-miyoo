This is currently my sum total documentation on the AMF format, and
until I find some binary AMF data to test with, it'll be hard to know
if I've got this initial reverse engineering project working
correctly. 

Anyone that gets the urge is welcome to split this library off from
Gnash and make it be a standalone development reesource. There don't
appear to be any GPL'd AMF tools out there that I could find non
WinDoze systems.

===========================================================

All of this info came from OSFlash:
http://osflash.org/amf


 AMF has core data types that are there every step of the way for
serializing data. These should not be confused with the AMF
actionscript data types. The core data types include:

    * Byte
    * Int
    * MediumInt
    * Long
    * Double
    * UTF8
    * LongUTF8

An AMF Byte is the simplest data type to read and write. It is simply
an 8-bit byte.

An AMF Int is made up of 2 consecutive bytes. It represents a 16-bit
number. The first byte in the file/stream is the most significant bit
and the second byte in the file/stream is the LSB. 

An AMF MediumInt is made up of 3 consecutive bytes. It represents a
24-bit number. The first byte in the file/stream is the most
significant bit and the third byte in the file/stream is the
LSB. MediumInt's appear to be used exclusively by FlashCom. 

The AMF Long is made up of 4 consecutive bytes. It represents a 32-bit
number. Like the Int and MediumInt, it is unsigned and the LSB is on
the right. 

The AMF Double is made up of 8 consecutive bytes. It represents a
floating point, signed number. The double is little-endian encoded. In
PHP a double can be read in the following way (this should also work
for any language that has a pack function): 

The AMF UTF8 represents a string shorter than 2^16 bytes. It is
composed of an Int (2 bytes) representing string length followed by
the UTF8-encoded string. 

The AMF LongUTF8 represents a string potentially longer than 2^16
bytes. It is composed of an LongInt (4 bytes) representing string
length followed by the UTF8-encoded string. 


Remoting envelope

A Remoting request from the client consists of a short preamble,
headers, and bodys. The preamble contains basic information about the
nature of the request. Headers can be used to request debugging
information, send authentication info, tag transactions, etc. Bodies
contain actual Remoting requests and responses. A single Remoting
envelope can contain several requests; Remoting supports batching out
of the box. 

Client headers and bodies need not be responded to in a one-to-one
manner. That is, a body or header may not require a response. Debug
information is requested by a header but sent back as a body
object. The response index is essential for Flash player to understand
the response therefore. 
Preamble

The first byte of the AMF file/stream is believed to be a version
indicator. So far the only valid value for this field that has been
found is 0◊00. If it is anything other than 0◊00 (zero), your
system should consider the AMF file/stream to be
'cmalformed'd. This can happen in the IDE if AMF calls are put
on the stack but never executed and the user exits the movie from the
IDE; the two top bytes will be random and the number of headers will
be unreliable.

The second byte of the AMF file/stream is appears to be 0◊00 if the
client is the Flash Player and 0◊01 if the client is the FlashCom
server. 

The third and fourth bytes form an integer value that specifies the
number of headers. 

AMF Headers

Each header consists of the following:

    * UTF string (including length bytes) - name
    * Boolean - specifies if understanding the header is `required'
    * Long - Length in bytes of header
    * Variable - Actual data (including a type code)

AMF headers may be user-created. However, certain headers have certain
meaning that a gateway should respond to. See predefined headers for
more information. 
AMF Bodies

Between the headers and the start of the bodies is a int specifying
the number of bodies. Each body consists of the following: 

    * UTF String - Target
    * UTF String - Response
    * Long - Body length in bytes
    * Variable - Actual data (including a type code)

The target may be one of the following:

    * An http or https URL. In that case the gateway should respond by
sending a SOAP request to that URL with the specified data. In that
case the data will be an array and the first key (data[0]) contains
the parameters to be sent. 
    * A string with at least one period (.). The value to the right of
the right-most period is the method to be called. The value to the
left of that is the service to be invoked including package name. In
that case data will be an array of arguments to be sent to the
method. 

The response is a string that gives the body an id so it can be
tracked by the player. 

Body response

The response to a request has the exact same structure as a request. A
request requiring a body response should be answered in the following
way: 

    * Target: set to Response index plus one of "/onStatus",
"onResult", or "/onDebugEvents". "/onStatus" is reserved for
runtime errors. "/onResult" is for succesful calls. "/onDebugEvents"
is for debug information, see debug information. Thus if the client
requested something with response index 1/1', and the call was succesful,
1/1/onResult' should be sent back. 
    * Response: should be set to the string `null'.
    * Data: set to the returned data.


==========================================================
http://www.vanrijkom.org/archives/2005/06/amf_format.html

Flash AMF

Used for:

    * Local Connection
    * SOL
    * Remoting

The folowing elements are defined within AMF. These are all based on
their ActionScript equivalants.

Type	Tagbyte

Number 0x00;
Boolean 0x01;
String 0x02;
Object 0x03;
MovieClip 0x04;
Null 0x05;
Undefined 0x06;
Reference 0x07;
ECMAArray 0x08;
ObjectEnd 0x09;
StrictArray 0x0a;
Date 0x0b;
LongString 0x0c;
Unsupported 0x0d;
Recordset 0x0e;
XMLObject 0x0f;
TypedObject(Class) 0x10;


For terminating sequences, a byte with value 0x09 is used.

Number: 0x00 B7 B6 í°ƒ B0

Numbers in AMF are 64 bit í°∆Big Endianí°«. Windows works with little
endians, so conversion is required. 

Boolean: 0x01 B0 (BOOL)

BOOL is 0 for FALSE and 1 for TRUE

String: 0x02 L0 L1 SMBSTRING

L1+L2 is Big Endian, length of the string. String is in multibyte
format, prefixed with a 2 byte Big Endian length specifier. 

Object: 0x03 [SMBSTRING AMFELEMENT ] 0x09

An object contains zero or more AMF elements that are prefixed with a
multibyte string that indicates the AMF elements identifyer within the
object. 

Undefined: 0x06

An undefined element consists of soley one byte with the value 0x06.

Reference (TODO): 0x07 ?

A reference refers to an array or object that stored somewhere
before. Ití°«s probably a mechanism that prevents 

Associative Array: 0x08 L3 L2 L1 L0 [SMBSTRING AMFELEMENT ] 0x09

L0..L3 for a 32 bit number indicating the number of elements present
in the array. The length of the array is followed by (length) AMF
elements that are prefixed with a multibyte string (with a 2 byte
length prefix) that indicates the AMF elements identifyer within the
array. 

Array: 0x0A L3 L2 L1 L0 [ AMFELEMENT ]

L0..L3 form a 32 bit Big Endian number indicating the number of
elements present in the array. The size of the array is followed by
(length) AMF elements. Note that this collection is NOT terminated using 0x09. 

Date: 0x0B T7 T6 .. T0 Z1 Z2

T7 to T0 form a 64 bit Big Endian number that specifies the number
of nanoseconds that have passed since 1/1/1970 0:00 to the
specified time. This format is í°»UTC 1970í°…. Z1 an Z0 for a 16 bit
Big Endian number indicating the indicated timeí°«s timezone. 

SimpleObject: 0x0C ?

To do %GÅ‚Äì%@ meaning unknown.

XML: 0x0F LMBSTRING

The multi-byte string is prefixed with a 32 bit Big Endian number,
indicating the length of the multibytestring that follows. 

Class: 0x10 SMBSTRING [ SMBSTRING AMFELEMENT ] 0x09

A class element is similar to an object element, but has a class
name indentifyer string prefixed to the array of member elements. 

*Element containers*

Currently AMF is used with SharedObjectsLocal (.sol) files,
Local Connection and Flash Remoting.


  // S3 .. S0 forms a 32 bit Big Endian number indicating the size of
  // the file. The small multibyte string reflects the name of the
  // object shared in the file. The array that follows has pairs of
  // name (SMBSTRING) lue pairs.
  
Reference tag
16 big big-endian number follows the tag identifier 0x07.
 
