<chapter id="extensions">
  <title>Gnash Extensions</title>
  
  <para>
    Gnash supports extending the SWF specification by creating
    custom ActionScript classes that are compiled code, as opposed to
    the existing method of defining custom classes as
    ActionScript. Executing compiled code has many performance
    benefits over having to interpret the byte stream of the
    ActionScript opcodes.
  </para>
  
  <para>
    I can already hear people complaining now about the concept of
    extending SWF, so this in no way affects Gnash's ability to play
    SWF movies when functioning as a browser plugin.
    Gnash's goal is still to function in a way that is compatible
    with the current proprietary Flash player.
  </para>

  <para>
    But at the same time, we see SWF as the ideal scripting language
    for a digital multi-media streaming environment. There are many
    resources for SWF movie creators for widgets, higher level APIs,
    all sorts of desirable things. But for those of use committed to
    using free software tools for SWF, our options are very
    limited. 
  </para>

  <para>
    Rather than launching a multi-year project to duplicate all
    classes in the commercial Flash IDE, it's much more efficient to
    use existing development libraries much like Python or Perl
    do. The extension mechanism in Gnash allows wrappers to be created
    for any C or C++ development library. Unlike the proprietary Flash
    IDE, which compiles all the extension libraries into byte codes
    from ActionScript, the support is moved to the player side. Movies
    with all of the goodies of the proprietary IDE in them play in
    Gnash just fine, as it's all just byte codes by then.
  </para>

  <para>
    This trick works because until SWF version 9, all the
    ActionScript class names and methods are passed as ASCII strings
    into the SWF movie. So the Gnash Virtual Machine just loads the
    extension file if that class name is invoked in the movie. All
    extension files specify the class name and methods it implements
    in an identical style as adding any new ActionScript class. The
    advantage is the class itself is compiled code, and runs much
    faster than the equivalent byte codes which all have to be
    interpreted..
  </para>

  <sect1 id="newext">
    <title>Creating A New Extension</title>

    <para>
      Each new extension should live in its own directory. The
      extensions included in Gnash are all in the
      <emphasis>gnash/extensions</emphasis> directory. Creating an extension
      requires a Makefile.am,
    </para>

    <para>
      If you are adding this extension to the Gnash source tree
      itself, then you need to make two changes to add the new
      extension.
    </para>

    <para>
      The first change is to add the directory to the list in
      extensions/Makefile.am. This can be done either by adding the
      new directory to the SUBDIRS setting, or by wrapping it in a
      conditional test.
    </para>

    <para>
      The other change is to add it to the AC_OUTPUT list in
      <emphasis>configure.ac</emphasis> so the new directory will be
      configured along with the rest of Gnash.
    </para>

    <para>
      Each extension should have an ActionScript source file included
      that tests the new class, and this file should be referenced in
      the new Makefile.am in the <emphasis>check_PROGRAMS</emphasis>
      variable so that "make check" works.
    </para>

    <para>
      When creating an extension that is a wrapper for an existing
      development library API, it's often better to make this a thin
      layer than to get carried away with creating beautiful
      abstractions. Higher-level classes that offer a lot of new
      functionality are fine, but is different from wrapping a library
      so it can be used from within Gnash.
    </para>

    <sect2 id="craftext">
      <title>Crafting an Extension</title>

      <para>
          An extension defines a built-in type of ActionScript object.
          An ActionScript object may have native type information known
          as a Relay. This adds an extra layer of complexity and runtime
          cost, so avoid using it unless necessary.
      </para>
      <para>
          ActionScript classes consist of a constructor function and a 
          prototype object. The constructor function is called when an
          instance of your extension class is created. The prototype object
          contains the properties inherited by instances of the extension
          class. To create an extension class, you must provide an entry
          function with the following signature:
      </para>
	  <programlisting>
	      void extension_init(as_object&amp; where, const ObjectURI&amp; uri);
      </programlisting>
      <para>
          This will be called during initialization. The first argument
          is the object to which your class will be attached. For extensions,
          this is the Global object, known as _global in ActionScript 2.0.
          The second argument is ignored for extension classes.
      </para>
      <para>
          Our extension class will imaginatively be called
          &quot;Extension&quot;. Our extension_init function takes care of
          attaching the prototype and constructor function to the passed object
          object. One way to do this is as follows:
      </para>
      <programlisting>
          void
          extension_init(as_object&amp; where, const ObjectURI&amp; uri) 
          {
              // Get a reference to the global object.
              Global_as&amp; gl = getGlobal(where);

              // Create a prototype object
              as_object* proto = gl.createObject();

              // Create the class
              as_object* cl = gl.createClass(&amp;extension_ctor, proto);

              // Attach the class's functions to the prototype object.
              attachInterface(*proto);

              // Attach static properties to the class itself
              attachStaticInterface(*cl);

              // Attach the class to the passed object.
              where.init_member("Extension", cl);
          }
      </programlisting>
      <para>
          You will notice three functions in the example above that need
          definition. The first two are attachInterface() and
          attachStaticInterface(). This is a convention
          in Gnash to separate ActionScript interface creation from the
          registration of our Extension class. We will see why this is
          useful later. The attachInterface function may be defined
          as follows:
      </para>
      <programlisting>
          void
          attachInterface(as_object&amp; obj)
          {
              Global_as&amp; gl = getGlobal(obj);
              obj.init_member("ext1", gl.createFunction(&amp;extension_ext1));
          }
      </programlisting> 
      <para>
          This attaches a function called ext1 to the Extension class
          prototype. When ext1 is called in ActionScript, Gnash will
          execute the C++ function named extension_ext1. This is known as
          a ActionScript callback function and must have the correct signature.
          We will deal with this next. The member function function will be
          inherited by all instances of Extension.
      </para>
      <para>
          The attachStaticInterface() function looks identical:
      </para>
      <programlisting>
          void
          attachStaticInterface(as_object&amp; obj)
          {
              Global_as&amp; gl = getGlobal(obj);
              obj.init_member("static1", gl.createFunction(&amp;extension_static1));
          }
      </programlisting> 
      <para>
          This does exactly the same as the previous function, but it
          attaches "static" properties to the class. Such functions can
          be called directly, that is, without requiring an instance of
          Extension:
      </para>
      <programlisting>
          Extension.static();
      </programlisting>
      <para>
          The other undefined function is extension_ctor. Like extension_ext1,
          this is an ActionScript callback function. Such functions have the
          signature:
      </para>
      <programlisting>
          as_value extension_ctor(const fn_call&amp; fn);
      </programlisting>
      <para>
          The fn_call type contains information about the ActionScript function
          call, including the number of arguments, the 'this' pointer (if
          present), the VM and the Global object. With one small exception,
          the constructor function extension_ctor, and the ext1 function 
          implementation, extension_ext1, do the same thing.
      </para>
      <para>
          The function extension_static is the simplest function. A possible
          implementation is as follows:
      </para>
      <programlisting>
          as_value
          extension_static(const fn_call&amp; fn)
          {
              // Reject any calls with no arguments. We must ensure that
              // we do not access out-of-range arguments.
              if (!fn.nargs) return as_value();

              // Convert the first argument to a double.
              const double d = fn.arg(0).to_number();

              // This is the return value of the function.
              return as_value(d * 6);
          }
      </programlisting>
      <para>
          The member function implementation extension_ext1 is barely more
          complex. It could look like this:
      </para>
      <programlisting>
          as_value extension_ext1(const fn_call&amp; fn)
          {
              // This ensures that the function can only be called as a
              // member function of an object. If not, execution of the
              // function ends at this point.
              as_object* this_ptr = ensure&lt;ValidThis&gt;(fn);

              // Reject any calls with no arguments.
              if (!fn.nargs) return as_value();

              const as_value&amp; arg0 = fn.arg(0);

              // The string table manages all strings; we refer to strings
              // by their index in the table.
              string_table&amp; st = getStringTable(fn);

              // Set a member named "property" on the object to the value of
              // the first argument.
              this_ptr->set_member(st.find("property"), arg0);

              // This is the return value of the function.
              return as_value("return value");
          }
      </programlisting>
      <para>
          It is not a very useful function. In ActionScript, this definition
          will have the following effect:
      </para>
      <programlisting>
          var e = new Extension();
          var i = e.ext1(8);
          trace(e.property) // traces "8"
          trace(i) // traces "return value"
      </programlisting>
      <para>
          The constructor function is very similar, but has a different
          purpose. When the actionscript "new Extension" is called,
          this extension_ctor function will be called with a newly-created
          object as the "this" object. Its job is to attach properties
          to the "this" object. Unlike the class prototype's propertes
          that we attached in the attachInterface function, any properties
          attached here belong directly to the new object.
      </para>
      <programlisting>
          as_value extension_ctor(const fn_call&amp; fn)
          {
              // When called as a constructor, there is always a "this" object
              as_object* this_ptr = ensure&lt;ValidThis&gt;(fn);

              // The init_member function will never replace an existing
              // property.
              this_ptr->init_member("myProperty", true);

              // A constructor function must not return anything.
              return as_value();
          }
      </programlisting>
      <para>
          You may not want to do anything in your constructor. It is perfectly
          valid to use the following as a constructor function (and indeed
          this is recommended unless you need more complex behaviour):
      </para>
      <programlisting>
          as_value extension_ctor(const fn_call&amp; fn)
          {
          }
      </programlisting>
      <para>
          If you have defined all the callback functions in the way
          described above, you can simplify the class registration. Gnash
          provides a convenience function to register a built-in class. In
          this case, your entry function would look like this:
      </para>
      <programlisting>
          void
          extension_init(as_object&amp; where, const ObjectURI&amp; uri) 
          {
              string_table&amp; st = getStringTable(where);
              registerBuiltinClass(where, extension_ctor, attachInterface,
                  0, st.find("Extension"));
          }
      </programlisting>
      <para>
          For more advanced extensions, you may want to store extra information
          in an object. You can do this using a Relay. This imposes type
          restrictions when using the object in ActionScript. A Relay is
          a C++ class that could look like this:
      </para>
      <programlisting>
          #include "Relay.h"
          #include &lt;complex&gt;

          class Complex : public Relay
          {
          public:
              typedef std::complex&lt;double&gt; type;
              Complex(type c = type()) : _c(c) {}
              type _c;
          };
      </programlisting>
      <para>
          Using this Relay involves two steps: attaching it, and accessing
          it. Relays must be attached in the constructor:
      </para>
      <programlisting>
          as_value extension_ctor(const fn_call&amp; fn)
          {
              as_object* this_ptr = ensure&lt;ValidThis&gt;(fn);
              this_ptr->setRelay(new Complex())
          }
      </programlisting>
      <para>
          To access this information in ActionScript callback functions, we
          must ensure that the object has the correct type of Relay attached.
          A toString function (which must also be attached to the prototype!)
          could look like this:
      </para>
      <programlisting>
          as_value
          extension_toString(const fn_call&amp; fn)
          {
              // This ensures that the function can only be called as a
              // member function of a genuine Complex object.
              Complex* c = ensure&lt;IsNativeType&lt;Complex&gt; &gt;(fn);

              std::ostringstream s;
              s &lt;&lt; "real:" &lt;&lt; c.real() &lt;&lt; ",imag: &lt;&lt; c.imag();
              // This is the return value of the function.
              return as_value(s.str());
          }
      </programlisting>
    </sect2>

  </sect1>

  <sect1 id="debuext">
    <title>Debugging An Extension</title>
    
    <para>
      As extensions are loaded dynamically at runtime, debugging one
      can be difficult. You can use GDB, but you have the problem of
      not being able to set a breakpoint in Gnash until
      <emphasis>after</emphasis> the extension has been loaded into
      Gnash's VM. The easy solution is to use the Gnash debugger.
    </para>

    <para>
      You can insert these few lines in any file that you wish to
      manually start the debugger. Once at the console, you can attach
      GDB to the process. Then you can set breakpoints, etc... and you
      are at the point of execution where the console was started. To
      then continue playing the movie, type the <emphasis>c</emphasis>
      (for continue) command to the Gnash console.
    </para>
    <programlisting>
      // Get the debugger instance
      static Debugger&amp; debugger = Debugger::getDefaultInstance();

      // Enable the debugger
      debugger.enabled(true);
      // Stop and drop into a console
      debugger.console();
    </programlisting>

    <para>
      You can also resort to the time honored technique of creating a
      loop before the point you want to set a breakpoint for. Gnash
      will stop playing the movie at this point, and then you can
      externally attach GDB to the running process, or type
      <emphasis>^C</emphasis> to drop into the GDB command console.
    </para>
    <programlisting>
      bool stall = true;
      while (stall) {
          sleep 1;
      }
    </programlisting>

    <para>
      Once you have set the breakpoints you want, reset the value of
      the <emphasis>stall</emphasis> variable to break out of the
      loop, and the SWF movie will then continue playing.
    </para>
    <programlisting>
      (gdb) set variable stall = false;
      continue
    </programlisting>

  </sect1>
  
  <sect1 id="inclext">
    <title>Included Extensions</title>

    <para>
      Gnash has some extensions included in the distribution. This is
      mostly because they were written by the Gnash team. Extensions
      can be external to gnash, Gnash needs no compiled in knowledge
      to load an extension file.
    </para>
    
    &gtkext;
    &fileext;
    &mysqlext;

  </sect1>

</chapter>
