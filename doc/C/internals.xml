<sect1 id="internals">
  <title>Software Internals</title>
  
  <sect2 id="tour">
    <title>A Tour of Gnash</title>
    
    <para>
      The top level of Gnash has several libraries, <code>libgnashbase</code>,
      <code>libgnashgeo</code>, <code>libgnashserver</code>,
      <code>libgasnhasobjs</code>and
      <code>libgnashbackend</code>. There are two utility programs 
      included for debug parsing and processing of Flash movie files
      to test the Actionscript interpreter. There is also a standalone
      flash movie player.
    </para>

    <sect3 id="The Libraries">
      <title>The Libraries</title>
      
      <sect4 id="libbase">
	<title>libgnashbase</title>
	
	<para>
	  Libgnashbase contains support classes used by the rest of the
	  code. Among these classes is a small and efficient STL library
	  clone that uses smart pointers. A current goal is to replace
	  this small STL clone with standard STL containers to reduce
	  the amount of code that has to be maintained, and to add
	  functionality not existing in the current smaller
	  implementation.
	</para>

	<para>
	  Gnash makes heavy use of smart pointers, so memory allocations
	  are freed up automatically by the interpreter.
	</para>
	
      </sect4>
      
      <sect4 id="libgnashgeo">
	<title>libgnashgeo</title>
	
	<para>
	  Libgnashgeo contains code for device independent graphics routines.
	</para>
	
      </sect4>

      <sect4 id="libgnashserver">
	<title>libgnashserver</title>
	<para>
	  Libgnashserver is the guts of the interpreter itself. This is where
	  the main code for the interpreter lives. 
	</para>
      </sect4>

      <sect4 id="libgnashasobjs">
	<title>libgnashasobjs</title>
	<para>
	  Libgnashasobjs contains all the ActionScript classes used by
	  the interpreter.
	</para>
      </sect4>

      <sect4 id="libgnashamf">
	<title>libgnashamf</title>
	<para>
	  AMF is the data format used internally by Flash. This is
	  Gnash's support library to handle AMF data. This is
	  currently unused, but when the LocalConnection class is more
	  fully implemented, this will be used to transfer data
	  between flash movies.
	</para>
      </sect4>
      
      <sect4 id="libgnashbackend">
	<title>libgnashbackend</title>
	
	<para>
	  Libgnashbackend is a small library containing OpenGL and SDL
	  code that glues this display to the Gnash display.
	</para>
	
      </sect4>
      <sect4 id="libgnashpluin">
	<title>libgnashplugin</title>
	
	<para>
	  Libgnashplugin is the Mozilla/Firefox plugin.
	</para>
	
      </sect4>
      <sect4 id="libklashpart">
	<title>libklashpart</title>
	
	<para>
	  Libklashpart is the Konqueror plugin.
	</para>
	
      </sect4>
    </sect3>


    <sect3 id="apps">
      <title>The Applications</title>
      
      <para>
	There are currently a few standalone programs in Gnash to
	assist with Gnash development, and to play a flash movie.
      </para>

      <sect4 id="Gnash">
	<title>The Standalone Player</title>
	
	<para>
	  This is the standalone OpenGL back-end used to play
	  movies. There are several command line options and keyboard
	  control keys used by Gnash that <link linkend="usage"> are
	  documented here.</link> 
	</para>

      </sect4>

      <sect4 id="parser">
	<title>Gparser</title>
	
	<para>
	  Gparser use the Gnash parser to disassemble the flash
	  movie, and dumps the object types, the depth, and other
	  information to make sure Gnash is parsing the file
	  correctly.
	</para>

      </sect4>
      <sect4 id="processor">
	<title>Gprocesser</title>
	
	<para>
	  Gprocesser is used to print out the actions (using the -va
	  option) or the parsing (using the -vp option) of a flash
	  movie. It is also used to produce the <code>.gsc</code>
	  files that Gnash uses to cache data, thereby speeding up the
	  loading of files.
	</para>

      </sect4>
    </sect3>
    
    <sect3 id="plugin">
      <title>The Plugin</title>

      <para>
	The plugin is designed to work within Mozilla or Firefox,
	although there is Konqueror support as well. The plugin uses
	the Mozilla NSPR plugin API to be cross platform, and
	portable, as well as being well integrated into Mozilla based
	browsers.
      </para>

      <para>
	One future thought for the plugin is to use the new Firefox
	1.5 or greater version of Firefox. This version has added a
	drawable canvas window that supports hardware acceleration, and
	is designed to support things like rendering directly into the
	canvas without needing OpenGL. 
      </para>

      <sect4 id="pluginstatus">
	<title>Current Status</title>
	<para>
	  As of March 30, 2006, the plugin works! This works in a
	  fashion similar to MozPlugger in that the standalone player
	  is used instead of using a thread. This gets around the
	  issue of having to maintain a seperate player to support the
	  plugin. It also gets around the other issues that Gnash
	  itself is not thread safe at this time.
	</para>
	<para>
	  There are a few limitations in the current implementation,
	  but it works well enough to be used for web surfing. The
	  main limitations are the SDL version has no event handling,
	  and sound doesn't work yet.
	</para>
      </sect4>

      <sect4 id="gui">
	<title>GUI Support</title>

	<para>
	  Any plugin that wants to display in a browser window needs
	  to be tied into the windowing system of the platform being
	  used. On GNU/Linux systems, Firefox is a GTK2+ application.
	  There is also KDE support through the use of the Klash
	  plugin.
	</para>

	<para>
	  Gnash can use either SDL or GTK now to create the window,
	  and to handle events for the standalone player. Work is
	  underway to add a portable interface for more windowing
	  toolkits to allow better embedded device support when
	  running in framebuffer only devices.
	</para>
	
	<para>
	  The SDL version is more limited, but runs on all
	  platforms, including win32. It has no support for event
	  handling, which means mouse clicks, keyboard presses, and
	  window resizing doesn't work. I personally find the default
	  event handler slow and unresponsive. Gnash has support to
	  use fast events, (currently not enabled) which is an SDL
	  hack using a background thread to pump events into the SDL
	  event queue at a much higher rate.
	</para>

	<para>
	  There are a variety of development libraries that build a GUI
	  widget system on top of SDL and OpenGL. The use of these to
	  add menus and dialog boxes to the SDL version is being
	  considered. 
	</para>

	<para>
	  The GTK support is currently the most functional, and the
	  best integrated into Firefox. The performance of this
	  version is better than the SDL version because of the more
	  efficient event handling within GTK. For the best end user
	  experience, use the GTK enabled version.
	</para>

	<para>
	  GTK also allows Gnash to have menus and dialog
	  boxes. Currently this is only being utilized in a limited
	  fashion for now. There is a right mouse button menu that
	  allows the user to control the movie being player the same
	  way the existing keyboard commands do.
	</para>

      </sect4>
      
      <sect4 id="mozplugger">
	<title>Mozplugger</title>

	<para>
	  <ulink type="http"
	 url="http://mozplugger.mozdev.org/">Mozplugger</ulink>. is a
	  <code>Mozilla/Firefox</code> plugin that uses external
	  programs to play video, audio, and other multimedia content
	  in the browser. With some support added to the external
	  application, it's possible to force the external program to
	  use the internal window in the browser where this plugin is
	  supposed to display. This enables one to then run the
	  standalone player and display it's output in the browser.
	</para>

	<para>
	  While this is not an optimal solution, it does enable one to
	  use Gnash as the flash player when browsing. The main issue
	  appears to be that the Flash movie being played doesn't get
	  any mouse or keyboard input. That may be a mozplugger
	  configuration issue though.
	</para>

	<para>
	  Use of MozPlugger is obsolete now that the Gnash plugin
	  works. Still this may be useful still on some platforms.
	</para>

	<para>
	  Add this to your <code>$(HOME)/.mozilla/mozpluggerrc</code>
	  file to enable this:

	  <programlisting>
	    application/x-shockwave-flash:swf:Shockwave Gnash
        nokill embed noisy ignore_errors hidden fill swallow(Gnash) loop: gnash -v "$file" -x $window
        : gnash -v "$file" -x $window
	  </programlisting>
	</para>

	<para>
	  Once this is added, you must delete the
	  <code>$(HOME)/.mozilla/firefox/pluginreg.dat</code> file to
	  force Firefox to register the plugins again. This is an
	  ascii text file, so if the patch has been added correctly,
	  you'll see an entry for <code>swf</code> files after it is
	  recreated. You will need to restart Firefox to recreate this
	  file.
	</para>

	<para>
	  This file is not recreated immediately when restarting
	  Firefox, but waits till the first time a plugin is used. You
	  can force creation of this file by typing
	  <code>about:plugins</code> into the URL entry of the browser
	  window. The output will also contain information about the
	  mozplugger. You should see an entry for Gnash now.
	</para>
	
      </sect4>

      <sect4 id="Klash">
	<title>Klash</title>
	<para>
	  Klash is MozPlugger type support for KDE's Konqueror web
	  browser. Klash makes Gnash a <code>kpart</code>, so it's
	  integrated into KDE better than when using MozPlugger. Klash
	  uses the standalone player, utilizing Gnash's "-x" window
	  plugin command line option.
	</para>

	<para>
	  By default, Klash is not built. To enable building Klash,
	  use the <code>--enable-klash</code> option when
	  configuring. Other than installing, there is nothing else
	  that needs to be done to install Klash.
	</para>
      </sect4>

      &plugin;

    </sect3>

    &logging;

  </sect2>

  <sect2 id="as">
    <title>ActionScript Support</title>

    <sect3 id="asadd">
      <title>Adding New ActionScript Classes</title>

      <para>
	Adding a new ActionScript class is a relatively simple
	process. A new file is created to hold the code, with an
	associated header file. The file name is usually the name of
	the ActionScript class itself, something like
	<code>XML</code>. All implementations are written in
	<code>C++</code>. In the CVS source tree for Gnash, there is a
	utility file called <code>gen-files.sh</code> that can be used
	to generate a template for a new ActionScript class. At this
	time templates have been generated for all documented
	ActionScript classes.
      </para>

      <sect4 id="defclass">
	<title>Defining a new ActionScript Class</title>

	<para>
	  The header file defines the class and it's methods. The symbol
	  name used to look up the code that implements the ActionScript
	  class is added later.
	</para>
	
	<para>
	  Each class needs an associated version that is a derived form
	  of the <code>as_object</code> class used to internally
	  represent objects in Gnash. At it's simplest, this structure
	  just encapsulates an object of the desired class.
	  
	  <programlisting>
	    class Foo {
	        public:
		    foo() {};
		    ~foo() {};
		    bool GetBar() { return _bar; }
		private:
		    bool _bar;
	    }
	    struct foo_as_object : public gnash::as_object {
	        Foo obj;
	    }
	  </programlisting>
	  The <code>obj</code> is an instantiation of the data for
	  this object. It isn't required unless this object needs
	  internal data that has to stay resident in the player.
	</para>

	<para>
	  Whenever this object is being handled the code for this
	  class, it is initially accessed by it's derived
	  binding. Internal data for this object can be accessed
	  through the <code>obj</code>.

	  <programlisting>
	    foo_as_object *foo = env.top(0).to_object();
	    bool result = foo->obj.GetBar();
	  </programlisting>

	</para>
	
	<para>
	  A more complex example might be to add hooks to the
	  constructor an destructor for the class to keep track of
	  memory allocations and cleanup. In this case only a debug
	  statement is printed.
	  
	  <programlisting>
	    struct foo_as_object : public gnash::as_object {
	        Foo obj;
	        foo_as_object() {
	            log_msg("\tCreating foo_as_object at %p \n", this);
	        };
	        ~foo_as_object() {
	            log_msg("\tDeleting foo_as_object at %p \n", this);
	        };
	    }:
	  </programlisting>	
	</para>
	
	<para>
	  An even more complex example might be to add hooks to how
	  the list of member of a class is kept. The element
	  <code>m_members</code>, is a list of each symbol name and it's
	  associated code. Normally this is kept internally within the
	  interpreter engine, but in this example for certain methods we
	  want to return a point to itself, instead of getting the data
	  from the list.
	  
	  <programlisting>
	    struct xml_as_object : public gnash::as_object {
	        XML obj;
	        xmlnode_as_object() {
	            log_msg("\tCreating xmlnode_as_object at %p \n", this);
	        };
	        ~xmlnode_as_object() {
	            log_msg("\tDeleting xmlnode_as_object at %p \n", this);
	        };
	        virtual bool get_member(const tu_stringi&amp; name, as_value* val) {
	            if ((name == "firstChild") || (name == "childNodes")) {
	                val->set_as_object_interface(this);
		        return true;
	            }
		    if (m_members.get(name, val) == false) {
		        if (m_prototype != NULL) {
		            return m_prototype->get_member(name, val);
	                }
		        return false;
		    }
	          return true;
	      }
	  };
	  </programlisting>	
	</para>
      </sect4>
      
      <sect4 id="instclass">
	<title>Instantiating a new Class</title>

	<para>
	  To add a new object to the list maintained by Gnash, it needs
	  to be added to the function <code>gnash::action_init()</code>,
	  in <code>action.cpp</code>. The symbol name is specified along
	  with a function pointer that will be called when the symbol
	  name is seen by the interpreter.
	  
	  <programlisting>
	    obj->set_member("XML", as_value(xml_new));
	  </programlisting>	
	</para>
	<para>
	  The function used to instantiate a new object is passed the
	  creation data in a <code>fn_call</code> data structure. This is
	  used to pass data both into and returned from this function.
	</para>
	
	<para>
	  The <code>fn_call</code> data structure has several methods
	  for operating on the data for the
	  function. <code>fn_call::nargs</code> is a variable that
	  soecifies how many arguments are being passed in. Al the
	  arguments are on a stack. To pop an argument off the stack,
	  use <code>fn.env->top(0)</code>. In this case popping the
	  first argument off the stack. 
	</para>
	
	<para>
	  The object popped off the stack also has it's own methods. The
	  main one of interest is <code>get_type</code>. This returns
	  the type of the object being referred to. 
	  
	  <programlisting>
	  if (fn.env->top(0).get_type() == as_value::STRING) {
	     ...
	  }
	  </programlisting>
	</para>
	
	<para>
	  The supported data types for an object are
	  <code>BOOLEAN</code>, <code>STRING</code>,
	  <code>NUMBER</code>, <code>OBJECT</code>,
	  <code>C_FUNCTION</code>, <code>AS_FUNCTION</code>.  Because
	  they are defined as part of the as_value class, they need to
	  always have the class name prefixed to use these as a
	  constant. You can retrieve the value of an
	  <code>as_value</code> using the conversion methods. For
	  example, <code>to_tu_string</code> returns the value as string
	  using the Gnash small STL library. Similarly,
	  <code>to_number</code> would return this same value as a
	  <code>double.</code>
	</para>
	
	<para>
	  To add methods to the class, a new class needs to be
	  instantiated as an object. Each ActionScript object can have
	  child methods attached in a similar way as the object was. In
	  this case, the built-in <code>set_member</code> function is
	  used.
	  
	  <programlisting>
	    xml_obj = new xml_as_object;
	    xml_obj->set_member("load", &amp;xml_load);
	  </programlisting>  
	</para>
	<para>
	  To make the object active within the interpreter, the new
	  object gets returned by the function using the
	  <code>fn_call</code> typed parameter.
	  
	  <programlisting>
	    fn.result->set_as_object_interface(xml_obj);
	  </programlisting>
	</para>
	
	<para>
	  A complete example of a function used to instantiate a new
	  ActionScript object is as follows. This example also calls
	  internally defined methods in the class, in this case to
	  process and XML file, and create the parsed XML tree.
	  
	  <programlisting>
	    void
	    xml_new(const fn_call&amp; fn) {
	        as_value      inum;
	        xml_as_object *xml_obj;
	    
	        if (fn.nargs > 0) {
	            if (fn.env->top(0).get_type() == as_value::STRING) {
	                xml_obj = new xml_as_object;
		        tu_string datain = fn.env->top(0).to_tu_string();
		        xml_obj->obj.parseXML(datain);
		        xml_obj->obj.setupFrame(xml_obj, xml_obj->obj.firstChild(), true);
	            } else {
	                xml_as_object *xml_obj = (xml_as_object*)fn.env->top(0).to_object();
		        fn.result->set_as_object_interface(xml_obj);
		        return;
	            }
	        } else {
	            xml_obj = new xml_as_object;
	            xml_obj->set_member("load", &amp;xml_load);
	            xml_obj->set_member("loaded", &amp;xml_loaded);
	        }
	        fn.result->set_as_object_interface(xml_obj);
	    }
	  </programlisting>
	</para>

	<sect5 id="defprop">
	  <title>Adding a Property</title>
	  
	  <para>
	    Adding a new new property to an object is similar to
	    adding a callback for a method. Instead of using a C
	    function, a string or number is used.

	    <programlisting>
	      as_obj->set_member("nodeName", as_value("HelloWorld"));
	    </programlisting>

	    When this is looked up by a Flash movie as a property, the
	    value is found, instead of needing to make a function
	    call. This scrap of ActionScript code as compiled by
	    Ming's <code>makeswf</code> compiler shows the
	    difference.

	    <programlisting>
	      // Call the hasChildNodes() function
	      if (node.hasChildNodes() == true) {
	          trace("CHILDREN");
	      }
	      // Get the value of the nodeName property
	      if (node.nodeName == "HelloWorld") {
	          trace("MATCHED");
	      }
	    </programlisting>

	  </para>
	</sect5>
      </sect4>
    </sect3>
    
    <sect3 id="parameters">
      <title>Parameter Passing</title>

      <para>
	Parameters are passed to the callback functions for a class's
	methods and properties using the <code>fn_call</code> data
	structure. This data structure contains all the incoming
	parameters for a callback, as well as it contains the final
	result from the callback to be passed back into the
	player.
      </para>

      <sect4 id="parain">
	<title>Getting Parameter Data</title>
	<para>
	  Parameter data is passed on the stack in a similar way to
	  any function call in any language. There are several fields
	  of the <code>fn_call</code> data structure that get used in
	  this example:

	  <programlisting>
	    xml_as_object *xml_obj = (xml_as_object*)fn.this_ptr;
	    if (fn.nargs) {
	        filespec = fn.env->bottom(fn.first_arg_bottom_index).to_string;
	    }
	  </programlisting>
	</para>
	<para>
	  Using the <code>fn</code> variable which was passed as the
	  sole parameter of the callback, we can access the data. The
	  <code>fn.this_ptr</code> returns a reference to the class
	  that is invoking this method. This is how the object data
	  can be retrieved. The <code>fn.nargs</code> is a count of
	  how many objects are being passed into the callback.
	</para>

	<para>
	  The current stack of the player is passed in via the
	  <code>fn.env</code> field. This is used to access the data
	  passes to this callback. To find the location of this
	  particular stack frame, the
	  <code>fn.first_arg_bottom_index</code> field is used to
	  point to the stack frame. More detail on the environment stack
	  can <link linkend="envstack">be found here.</link>.
	</para>

	<para>
	  For this example, the stack has a
	  <code>as_environment::top()</code> and a
	  <code>as_environment::bottom()</code> that are used to pull
	  arguments off the stack. When using
	  <code>fn.first_arg_bottom_index</code>, the
	  <code>as_environment::bottom()</code> method should be used
	  as in the example.
	</para>
	
	<para>
	  The top of the stack for this frame can also be accessed
	  using the <code>as_environment::top()</code> method. Top
	  takes an integer index as to which value to retrieve,
	</para>

	<programlisting>
	  if (fn.nargs > 0) {
	   name = fn.env->top(0).to_string());
	  }
	</programlisting>
	  
	<para>
	  If the type of the object is needed, that can be accessed by
	  using the <code>as_value::get_type()</code> method. There
	  are more details on the types of values in the 
	  <link linkend="handval">Handling Values</link> section of
	  this manual.
	</para>

	<programlisting>
	  if (fn.nargs > 0) {
	      if (fn.env->top(0).get_type() == as_value::STRING) {
	          name = fn.env->top(0).to_string);
	      } 
	      if (fn.env->top(0).get_type() == as_value::NUMBER) {
	          value = fn.env->top(0).to_number);
	      } 
	  }
	</programlisting>

	<para>
	  The internal data for this object can be accessed through
	  the base class. Any data set using this object will stay
	  resident in the player.

	  <programlisting>
	     foo_as_object *foo_obj = (foo_as_object*)fn.this_ptr;
	     bool bar = foo_obj->obj.GetBar();
	  </programlisting>

	</para>

      </sect4>
      
      <sect4 id="paramout">
	<title>Returning Data</title>

	<para>
	  Data is also returned in the data structure passed to the
	  callback. This example calls a method of the object passed
	  in on the stack, and then sets the return code to be the
	  return code of calling the method.
	  <programlisting>
	    // Set the argument to the function event handler based on
	    // whether the load was successful or failed.
	    ret = xml_obj->obj.load(filespec);
	    fn.result->set_bool(ret);
	  </programlisting>
	</para>

	<para>
	  The <code>result</code> field of the <code>fn</code>
	  variable is a <code>gnash::as_value</code> object., so it's
	  possible to set the value of several data types.
	</para>
	
	<para>
	  Here is a short list of the most often used data types
	  returned from callbacks:
	  <variablelist>
	    <varlistentry>
	      <term>as_value::set_bool()</term>
	      <listitem>
		<para>
		  Set the result to a boolean value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_int()</term>
	      <listitem>
		<para>
		  Set the result to an integer value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_double()</term>
	      <listitem>
		<para>
		  Set the result to a floating point double value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_string()</term>
	      <listitem>
		<para>
		  Set the result to a <code>const char*</code> value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_as_object_interface()</term>
	      <listitem>
		<para>
		  Set the result to an object value.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect4>
      
    </sect3>
      
    <sect3 id="exists">
      <title>Level of Conformance</title>

      <para>
	Gnash is a capable of reading SWF v7 files and opcodes. Not
	all ActionScript classes are implemented yet, but all of the
	most heavily used ones are. Many ActionScript classes are
	partially implemented, there is support for all of the
	commonly used methods of each class.
      </para>

      <para>
	This is a quick list of what is currently implemented in Gnash
	as of January, 2006.

	<informaltable frame="all">
	  <?dbhtml table-width="75%" ?>
	  <tgroup cols="3">
	    <colspec colname="COLSPEC1" colwidth="2*"/>
	    <colspec colname="COLSPEC2" colwidth="2*"/>
	    <colspec colname="COLSPEC3" colwidth="*"/>
	    <thead>
	      <row>
		<entry valign="top">
		  <para>Class Name</para>
		</entry>
		<entry valign="top">
		  <para>When Added</para>
		</entry>
		<entry valign="top">
		  <para>Conformance</para>
		</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry valign="top" align="left">
		  <para><link linkend="asarray">_global</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		  </para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    Partially implemented.
		  </para>
		</entry>
	      </row>
	      <row>
		<entry valign="top" align="left">
		  <para><link linkend="asarray">Accessibility</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v7 ???
		  </para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    Unimplemented.
		  </para>
		</entry>
	      </row>
	      <row>
		<entry valign="top" align="left">
		  <para><link linkend="asarray">Array</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    Partially Implemented.
		  </para>
		</entry>
	      </row>
	      <row>
		<entry valign="top" align="left">
		  <para><link linkend="asboolean">Boolean</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Fully implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asbutton">Button</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Most all the functionality is implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="ascamera">Camera</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="ascolor">Color</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unknown
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="ascontextmenu">ContextMenu</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v7
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented.
		  </para>
		</entry>
	      </row>
	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="ascustomactions">CustomActions</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented		   
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asdate">Date</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented.
		  </para>
		</entry>
	      </row>
	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="aserror">Error</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v7
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>


	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asfunction">Function</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="askey">Key</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Fully implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asloadvars">LoadVars</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="aslocalconnection">LocalConnection</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asmath">Math</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v4
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Fully implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asmicrophone">Microphone</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asmouse">Mouse</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Most all the functionality is implemented. 
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asmovieclip">MovieClip</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v3
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asmoviecliploader">MovieClipLoader</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v7
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Barely implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asnetconnection">NetConnection</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v7
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asnetstream">NetStream</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v7
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asnumber">Number</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asobject">Object</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented.
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asselection">Selection</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="assharedobject">SharedObject</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="assound">Sound</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asstage">Stage</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
		  <para><link linkend="asstring">String</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="assystem">System</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="astextfield">TextField</link></para>
		</entry>
		<entry valign="top" align="center">
	 	  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="astextformat">TextFormat</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Partially implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asvideo">Video</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v6
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Unimplemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asxml">XML</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Almost fully implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asxml">XMLNode</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Almost fully implemented
		  </para>
		</entry>
	      </row>

	      <row>
		<entry valign="top" align="left">
 		  <para><link linkend="asxmlsocket">XMLSocket</link></para>
		</entry>
		<entry valign="top" align="center">
		  <para>
		    swf v5
		  </para>
		</entry>
		<entry valign="top"  align="center">
		  <para>
		    Almost fully implemented
		  </para>
		</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</informaltable>
      </para>

      &asaccessibility;
      &asarray;
      &asboolean;
      &asbutton;
      &ascamera;
      &ascolor;
      &ascontextmenu;
      &asmath;
      &asnetconnection;
      &asnumber;
      &asstring;
      &ascustomactions;
      &asdate;
      &aserror;
      &asfunction;
      &askey;
      &asloadvars;
      &aslocalconnection;
      &asmicrophone;
      &asmouse;
      &asmovieclip;
      &asmoviecliploader;
      &asnetstream;
      &asobject;
      &asselection;
      &assharedobject;
      &assound;
      &asstage;
      &assystem;
      &astextfield;
      &astextformat;
      &astextsnapshot;
      &asvideo;
      &asxmlnode;
      &asxml;
      &asxmlsocket;

    </sect3>
  </sect2>
  
  &opcodes;

  <sect2 id="engine">
    <title>The Interpreter Engine</title>
    <para>
      FIXME:
    </para>
    
    <sect3 id="loop">
      <title>The Main Loop</title>
      <para>
	FIXME:
      </para>
    </sect3>
    
    <sect3 id="io">
      <title>I/O Processing</title>
      <para>
	FIXME:
      </para>
    </sect3>
    
    <sect3 id="handval">
      <title>Handling Values</title>

      <para>
	All of the main values in Gnash as used by the interpreter,
	are usually an <code>as_value</code> class. This is a generic
	object to hold data. The supported data types for an object
	are <code>BOOLEAN</code>, <code>STRING</code>,
	<code>NUMBER</code>, <code>OBJECT</code>,
	<code>C_FUNCTION</code>, <code>AS_FUNCTION</code>. You can
	retrieve the value of an <code>as_value</code> using the
	conversion methods. For example, <code>to_tu_string</code>
	returns the value as string using the Gnash small STL
	library. Similarly, <code>to_number</code> would return this
	same value as a <code>double.</code>
        </para>

	<para>
	  <code>as_value</code> is often used as the initializer for a
	  property or the data for a callback. This is done so the
	  type of the object is specified along with the data.

	  <programlisting>
	    // Set the callback for a new XML object
	    obj->set_member("XML", as_value(xml_new));

	    // Set the property to the value of text
	    obj->set_member("nodeName", as_value(text));
	    
	    // Set the property to null, but at least it exists
	    obj->set_member("nodeValue", as_value(""));
	  </programlisting>
	</para>

	<para>
	  
	  <programlisting>
	    // Get the name of an object
	    name = fn.env->top(0).to_string());

	    // Get the value of an object
	    value = fn.env->top(1).to_number);

	  </programlisting>
	</para>

	<sect4 id="valset">
	  <title>as_value set methods</title>

	  <para>
	    While <code>as_value</code> allows you to use any of the
	    supported data types when invoking the constructor (as in
	    the prior example). This is a common way to set the data
	    and type of a value. Often it's necessary to set the value
	    of an object after it is created, or to change the
	    existing value. The <code>=</code> operator is also
	    supported, so it is also possible to set a value and it's
	    type this way as well. I sort of lean towards the explicit
	    style of setting a type, so here's all the methods that
	    explicitly set a value.
	  </para>

	  <variablelist>
	    <varlistentry>
	      <term>as_value::set_bool(bool)</term>
	      <listitem>
		<para>
		  Set the value to a boolean value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_int(int)</term>
	      <listitem>
		<para>
		  Set the value to an integer value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_double(double)</term>
	      <listitem>
		<para>
		  Set the value to a floating point double value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_string(const char*)</term>
	      <listitem>
		<para>
		  Set the value to a <code>const char*</code> value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_tu_string(int)</term>
	      <listitem>
		<para>
		  Set the value to an tu_string value. Once all the
		  containers have been converted to using standard
		  STL classes, this method will go away.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_nan(int)</term>
	      <listitem>
		<para>
		  Set the value to an NaN (Not a Number) value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_null()</term>
	      <listitem>
		<para>
		  Set the value so this is a <code>NULL</code>
		  object.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_undefined()</term>
	      <listitem>
		<para>
		  Set the value so this is an <code>undefined</code>
		  object.
		</para>
	      </listitem>
	    </varlistentry>


	    <varlistentry>
	      <term>as_value::set_as_object_interface(as_object *)</term>
	      <listitem>
		<para>
		  Set the value to an object value.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>as_value::set_as_c_function_ptr(int)</term>
	      <listitem>
		<para>
		  Set the value to an  value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::set_function_as_object(int)</term>
	      <listitem>
		<para>
		  Set the value to an  value.
		</para>
	      </listitem>
	    </varlistentry>


	  </variablelist>
	</sect4>

	<sect4 id="valget">
	  <title>as_value get methods</title>

	  <para>
	  </para>

	  <variablelist>
	    <varlistentry>
	      <term>as_value::to_bool(bool)</term>
	      <listitem>
		<para>
		  Return the value as a boolean.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::to_number()</term>
	      <listitem>
		<para>
		  Return the value as an number object.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::to_string()</term>
	      <listitem>
		<para>
		  Return the value as a <code>const char*</code>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::to_tu_string(int)</term>
	      <listitem>
		<para>
		  Return the value as a tu_string value. Once all the
		  containers have been converted to using standard
		  STL classes, this method will go away.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::is_nan()</term>
	      <listitem>
		<para>
		  Return true if set to NaN (Not a Number).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::is_inf()</term>
	      <listitem>
		<para>
		  Returns true if the number has an infinite value.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::is_finite()</term>
	      <listitem>
		<para>
		  Returns true if the number has an finite value.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>as_value::to_object()</term>
	      <listitem>
		<para>
		  Return the value as an
		  <code>as_object_interface</code>. This is often used
		  as the "handle" for an object within Gnash. You
		  would use this when you need to do
		  <code>set_member()</code> or
		  <code>get_member()</code> operations.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>as_value::to_c_function()</term>
	      <listitem>
		<para>
		  Return the value as a C function pointer.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>as_value::to_as_function()</term>
	      <listitem>
		<para>
		  Return the value as an ActionScript function.
		</para>
	      </listitem>
	    </varlistentry>


	  </variablelist>
	</sect4>

    </sect3>
    
    <sect3 id="handobj">
      <title>Handling Objects</title>
      <para>
	FIXME:
      </para>
    </sect3>
    
    <sect3 id="envstack">
      <title>The Environment Stack</title>
      <para>
	FIXME:
      </para>
    </sect3>
    
  </sect2>

  <sect2 id="testing">
    <title>Testing Support</title>

    <sect3 id="testtools">
      <title>Testing Tools</title>

      <para>
	Currently Gnash uses other three tools to help with
	testing. Two of these are free compilers for the Flash
	format. This lets us write simple test cases for Gnash to test
	specific features, and how they need to operate.
      </para>

      <para>
	The primary compiler used at this time is <ulink type="http"
	url="http://ming.sf.net">Ming</ulink>. The latest release of
	<code>Ming</code> included the compiler,
	<code>makeswf</code>. This lets test case development happen
	purely with free tools.
      </para>
      
      <para>
	The other tools used, although optional, is 
	<ulink type="http"
	       url="http://www.gnu.org/software/dejagnu">DejaGnu</ulink>.
	This is used to run multiple test cases in an automated
	manner. <code>DejaGnu </code> is used by many other <ulink
	type="http" url="http://www.gnu.org">GNU</ulink> projects like 
	<ulink type="http" url="http://gcc.gnu.org">GCC</ulink> and 
	<ulink type="http" url="http://www.samba.org">Samba</ulink>.
      </para>
      
    </sect3>

    <sect3 id="testcases">
      <title>Test Cases</title>
      
      <para>
	Ming-based ActionScript test cases are located under
	testsuite/actionscript.all/. Other directories under
	testsuite/ are (or shall be) used for other kind of tests.
      </para>

      <para>
	Writing Ming-based tests is very simple. The
	<code>makeswf</code> compiler makes use of the C preprocessor,
	thus allowing definition of macros and external files
	inclusion. We use these feature to provide common utilities
	for test units.
      </para>
      
      <para>
	Each test unit includes the <code>check.as</code> file and checks
	expressions expected to evaluate to true. Here is an example:
	
	<programlisting>
	  #include "check.as"
	  
	  // Test object creation
	  check(new Object() instanceOf Object);
	  
	  // Test parseInt
	  check(isNaN(parseInt('none')));

	  // Test assignment
	  var a = 1;
	  check_equals(a, 1);
	  
	  // .. your tests here ...
	</programlisting>
      </para>
      
      <para>
	The check(expr) macro will <code>trace</code> PASSED or FAILED
	together with the expression being evaluated, the filename and
	the linenumber of the check. This is the format expected by
	DejaGnu.
      </para>

      <para>
	The <code>check_equals(obtained, expected)</code> macro uses equality operator
	<code>==</code> to check for equality. When possible, use of the
	<code>check_equals()</code> macro is preferred over <code>check()</code>
	in that it shows what the obtained result was in case of a mismatch. 
	DejaGnu.
      </para>
      
      <para>
	Additionally, the check.as file provides a transparent way to send
	results to a TextField rather then using trace. This is very useful
	when you happen to run a flash player w/out tracing support.
      </para>
      
      <para>
	Test units are built by running <code>make TestName.swf</code>.
	This will use TestName.as as source. To build "visual" tracing
	version you'd run <code>make TestName.vswf</code>.
      </para>
      
      <para>
	Note that if you get a syntax error from the compiler, the line
	number will refer to the pre-processed file. This file is called
	<code>TestName.as.pp</code> and it's not thrown away by
	<code>makeswf</code> to make debugging easier.
      </para>
      
    </sect3>

    <sect3 id="runtests">
      <title>Running The Tests</title>

      <sect4 id="dejagnu">
	<title>Using DejaGnu</title>

	<para>
	  The simple way to run the tests is to install
	  <code>DejaGnu</code>, and use that to run the tests. That
	  handles all the details to compile and execute the tests. To
	  run the tests using DejaGnu, change to the
	  <code>testsuite</code> directory and type:
	  <programlisting>
	    make check
	  </programlisting>
	</para>
	
	<para>
	  You can get more details by adding command line option when
	  invoking <code>make</code>. The <code>make check</code> target
	  in the Makefile supports a variable, <code>RUNTESTFLAGS</code>
	  that gets passed to DejaGnu when it's invoked by <code>make</code>.
	  
	  <programlisting>
	    make check RUNTESTFLAGS="-v -a"
	  </programlisting>
	  
	  This adds the<code>verbose (-v)</code> option and the
	  <code>all (-a)</code> option. Verbose prints much more
	  information about how DejaGnu is running the test. It may be
	  too much information, but if you think you are having a
	  problem with running a test case, this is a good way to track
	  it down. The <code>all</code> option tells DejaGnu to print
	  all the tests that <code>PASS</code>, as well as those that
	  <code>FAIL</code>.
	</para>
      </sect4>

      <sect4 id="manually">
	<title>Manually Running Tests</title>

	<para>
	  You can also run all the test cases by hand, which is useful
	  if you want to see all the debug output from the test
	  case. Often the debug message that come deep from within
	  Gnash are the most useful during development.
	</para>

	<para>
	  The first step is to compile the test case. Ming's
	  <code>makeswf</code> program is used to compile the test
	  case into Flash. By default, no options are
	  required. Running <code>makeswf</code> looks like this:

	  <programlisting>
	    shellprompt> makeswf XML.as
	    Output file name: out.swf
	    Output compression level: 9
	    Output SWF version: 6
	    Preprocessing XML.as... done.
	    Compiling `XML.as.pp' into frame 1... done.
	    Saving output to out.swf... done.
	  </programlisting>
	</para>

	<para>
	  Once you have the flash movie version of the test case, you
	  can run it through the Gnash standalone player with a few
	  options that enable a simple test cases to be run that has no
	  associated graphics display, and consists only of unit level
	  tests for an ActionScript class.
	</para>
	<programlisting>
	  shellprompt> gprocessor -v out.swf
	  PASSED: XML::XML() constructor
	  PASSED: XML::addRequestHeader() exists
	  PASSED: XML::appendChild() exists
	  ...
	</programlisting>

      </sect4>
    </sect3>
  </sect2>
</sect1>

