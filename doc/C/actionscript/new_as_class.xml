    <sect1 id="newclass">
      <title>Adding New ActionScript Class</title>

      <para>
        Adding a new ActionScript class is relatively simple, but the
        process is complicated by the fact that the interface has evolved
        over time and the current code base represents several different
        formats.  This document describes the current interface.  The
        Boolean class should be considered the authoritative example of
        a modern ActionScript class.
      </para>

      <para>
        ActionScript classes contain a header file and a C++
        implementation.  The name is usually the name of the
        class as it is called in the ActionScript specifications;
        for instance <emphasis>Boolean.cpp</emphasis> for the Boolean class.
      </para>

      <para> 
        In the CVS source tree, there is a utility file named
        &gen_asclass; which can be used to
        create the header file and a C++ source file stub for
        an ActionScript class.  
      </para>

      <sect2 id="prototype">
        <title>Prototype</title>

	<para>
          In ActionScript, a prototype is a base object which contains
          all the methods that an instantiated object will contain.
          In short, it contains every part of the class except for
          the portions dealing with the storage of instance data.
	</para>
	<para>
          In Gnash, the prototype of an ActionScript object is 
          implemented as an <emphasis>as_object</emphasis>.
          At startup, the methods and properties of the ActionScript class
          are attached to the <emphasis>as_object</emphasis>.  The
          following example demonstrates how methods can be attached:
	  <programlisting>
            static void
            attachBooleanInterface(as_object&amp; o) 
            {
                o.init_member("toString", new builtin_function(boolean_tostring));
                o.init_member("valueOf", new builtin_function(boolean_valueof));
            }
	  </programlisting>
          This code was generated using &gen_asclass;.
          Typically, you will need to customize the attach method to include
          any new methods you add to the class.
	</para>
	<para>
          Static properties can also be added to the ActionScript prototype
          (<link linkend="properties">dynamic properties</link> 
          are addressed later).  They are attached in a similar way:
          <programlisting>
	    o.init_member("myProperty", as_value("HelloWorld"));
	  </programlisting>
	</para>
	<para>
          Properties which have been added in this manner can be
          directly accessed in ActionScript code without a function
          call, as this piece of ActionScript code compiled by Ming's
          <emphasis>makeswf</emphasis> compiler demonstrates:
	    <programlisting>
	      // Get the value of the myProperty property
	      if (node.myProperty == "HelloWorld") {
	          trace("MATCHED");
	      }
	    </programlisting>
	</para>
      </sect2>

      <sect2 id="declaration">
	<title>Declaration</title>

	<para>
          A new class should derive from <emphasis>as_object</emphasis>,
          which is the base class of every ActionScript object in Gnash.
          The class declaration will also be generated when you use
          &gen_asclass;.
	</para>
      </sect2>
      
      <sect2 id="instantiation">
	<title>Instantiation</title>

	<para>
          The class should contain an init method; this is included
          in the stub when &gen_asclass; is
          used.
	</para>
	<para>
          The init method should be called in the constructor in
          <emphasis>Global.cpp</emphasis>, where all other ActionScript
          classes are similarly referenced.
	</para>
      </sect2>

      <sect2 id="methods">
	<title>Methods</title>

        <para>
          Every method you implement and 
          <link linkend="prototype">attach</link> will receive an
          &fn_call; data structure as an argument when it is called.
          The most important members of the &fn_call; structure are
          the <link linkend="arguments">stack of arguments</link>
          to the function and a
          <link linkend="return">pointer to the result</link>, which will
          be returned to the (ActionScript) caller.  The remainder
          of the <link linkend="additional_fn_call">&fn_call; 
          structure</link> is described later in this section.
        </para>

        <sect3 id="arguments">
          <title>Accessing Arguments</title>
          <para>
            The arguments stored in &fn_call;
            should be accessed using <emphasis>arg()</emphasis>.  For
            instance, the first element can be popped with
            <emphasis>fn.arg(0)</emphasis>.
	  </para>
          <para>
            The element popped off the stack is an 
            <link linkend="as_value"><emphasis>as_value</emphasis>
            object</link>.
          </para>
        </sect3>

        <sect3 id="return">
          <title>Returning a Value to ActionScript</title>
          <para>
            The return value should be set <emphasis>result</emphasis>
            pointer of the &fn_call; structure.  For example:
            <programlisting>
              fn.result->set_string('Goodbye, cruel world.');
            </programlisting>
          </para>
          <para>
            The return value is an 
            <link linkend="as_value"><emphasis>as_value</emphasis> 
            object</link>.
          </para>
        </sect3>

        <sect3 id="additional_fn_call">
          <title>Additional &fn_call; Members</title>
          <para>
            In addition to the aforementioned 
            <link linkend="return">result pointer</link>, there
            are two other useful members of the &fn_call;
            structure, namely <emphasis>this_ptr</emphasis> and
            <emphasis>nargs</emphasis>.  The former points to the
            class which is invoking this method, while the latter
            is a count of the number of 
            <link linkend="arguments">arguments in the stack</link>.
            You may also see instances of the <emphasis>env</emphasis>
            pointer being used, but it has been deprecated.
	  </para>
          <para>
            Beyond the <emphasis><link 
            linkend="arguments">arg()</link></emphasis> method, there
            is one method of note.  <emphasis>dump_args()</emphasis>
            can be used in debugging to output the entire argument
            stack.
	  </para>
        </sect3>
      </sect2>

      <sect2 id="properties">
	<title>Dynamic Properties</title>
        <para>
          This section describes accessors to dynamic properties.
          Read-only properties are described
          in the <link linkend="prototype">prototype</link> section.
        </para>
        <para>
          Dynamic properties are not created by the &gen_asclass; 
          script.  Accessors should be written as
          a single get/set method.  Previously this was done by
          overriding <emphasis>get_member()</emphasis> and
          <emphasis>set_member()</emphasis>, but this practice
          is deprecated.  
        </para>
        <para> 
          The accessor is written so that it sets the property
          if it is called with an argument, and puts the property in
          the <link linkend="methods">&fn_call;</link>
          <link linkend="return">result pointer</link>.  For instance:
          <programlisting>
            void
            MyClass::myProperty_getset(const fn_call&amp; fn)
            {

               MyClass* ptr = ensureMyClass(fn.this_ptr);

               // setter
               if ( fn.nargs > 0 )
               {
                 bool h = fn.arg(0).to_bool();
                 ptr->MyMethod(h);
                 return;
               }

               // getter
               bool h = ptr->MyMethod();
               fn.result->set_bool(h);
            }
          </programlisting>
        </para>
        <para> 
          It has not yet been decided whether properties should be set
          in the <link linkend="prototype">exported interface</link> 
          or attached to instances of the class.  A property is attached
          in the following manner:
          <programlisting>
            boost::intrusive_ptr&lt;builtin_function&gt; gettersetter;
            gettersetter = new builtin_function(&amp;MyClass::myProperty_getset, NULL);
            o.init_property("myProperty", *gettersetter, *gettersetter);
          </programlisting>
        </para>
      </sect2>
    </sect1>
