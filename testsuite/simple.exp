
load_lib "dejagnu.exp"


# If tracing has been enabled at the top level, then turn it on here
# too.
if $tracelevel {
    strace $tracelevel
}

# After these many seconds of execution the test script is aborted with a failure.
# This is to handle deadlocks. We don't reset the timeout when a match is
# found to avoid hanging in case of a testcase sending matches in an infinite loops.
# (not unlikely as it seems, think about flash movies...)
set timeout 240 
set file all
set params ""

# testcases is set by the Makefile in the site.exp data file.
foreach file $testcases {

    verbose "Running test $file"

    # spawn the executable and look for the DejaGnu output messages from the
    # test case.

    # this version of the call allows use of 'wait' to check return code
    # -open [open "|cmd" "r"] doesn't work for that
    spawn -noecho ./$file 

    expect {
	-re "NOTE:\[^\n\r\]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*NOTE: " $expect_out(0,string) "" output
	    set output [string range $output 0 end-2]
	    verbose "${file} $output" 
	    exp_continue -continue_timer
	}
	-re "XPASSED:\[^\n\r\]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*XPASSED: " $expect_out(0,string) "" output
	    set output [string range $output 0 end-2]
	    xpass "${file}: $output"
	    exp_continue -continue_timer
	}
	-re "PASSED:\[^\n\r\]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*PASSED: " $expect_out(0,string) "" output
	    set output [string range $output 0 end-2]
	    pass "${file}: $output"
	    exp_continue -continue_timer
	}
	-re "XFAILED:\[^\n\r]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*XFAILED: " $expect_out(0,string) "" output
	    set output [string range $output 0 end-2] 
	    xfail "${file}: $output"
	    exp_continue -continue_timer
	}
	-re "FAILED:\[^\n\r\]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*FAILED: " $expect_out(0,string) "" output
	    set output [string range $output 0 end-2] 
	    fail "${file}: $output"
	    exp_continue -continue_timer
	}
	-re "UNTESTED:\[^\n\r\]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*TESTED: " $expect_out(0,string) "" output
	    set output [string range $output 8 end-2]
	    untested "${file}: $output"
	    exp_continue -continue_timer
	}
	-re "UNRESOLVED:\[^\n\r\]*\[\n\r\]" {
	    regsub "\[\n\r\t\]*UNRESOLVED: " $expect_out(0,string) "" output
	    set output [string range $output 8 end-2]
	    unresolved "${file}: $output"
	    exp_continue -continue_timer
	}
	-re "Totals" {
	    verbose "All done" 2
	}
	eof {
	    #	    unresolved "${file} died prematurely"
	    #	    catch close
	    #	    return "${file} died prematurely"
	}
	timeout {
		fail "Test case ${file} still running after ${timeout} seconds, killing it (deadlock?)"
		catch close
		continue;
	}
   }

	# wait for the process to coplete to
	# check return code
	set retcode [wait]

	# debugging
	#set i 0; foreach j $retcode { print "${file} wait($i) $j"; incr i }

	if { [ llength $retcode ] > 5 } {
		fail "${file} died prematurely ([lindex $retcode 6])"
	}
	if { [ lindex $retcode 3 ] != 0 } {
		fail "${file} exited with non-zero code ([lindex $retcode 3])"
	}



    # force a close of the executable to be safe.
    catch close
}


