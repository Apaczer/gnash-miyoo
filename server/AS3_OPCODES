These are the opcodes for Actionscript ByteCode in AS3. They are executed
in the Abc block of a V9+ .swf file.

The following opcodes were summarized from the Tamarin code base, used under
the GPL. 

Codes may have the following attributes:

Hex: The hexadecimal value of the code. Note that many of these codes changed
 from AS2 to AS3 -- the code numbers are not comparable between the two.
Name: The name, as given in the Tamarin source, plus my speculation of just
 what may have been the thought behind the name, when it didn't seem obvious
 to me.
StacK In: The entries expected on the stack, with the top of the stack being
 the last entry listed.
Stack Out: The stack as it leaves the operation, compared to how it entered.
 If it doesn't appear on the Stack In list, it won't be touched by the
 operation. Only operations 0x2A (swap) and 0x2B (dup) leave more than one
 value on the stack.
Stream: The state of the bytestream as it is known to be. The bytestream is
 used to store some values, and the order in which these are listed (left to
 right) is the order in which they should appear in the stream.
 The types V32 and UV32 are the variable encoding scheme 30 bit numbers,
 stored in a 32 bit signed integer (unsigned for UV32).
 The type S24 is a signed 3 byte number stored in 3 bytes in the stream.
 Stream reads should always advance the stream point, unless otherwise noted.
Frame: Accesses of the frame pointer are listed here.
Names: Some operators have [ns [n]] on the stack. Some names read from the
 stream need additional context information, and these optional atoms can
 provide that information.
See: Some operations are either identical to others or so similar that they
 are best described in terms of those operations.
Do: If the intent of the opcode is not obvious from the stack and stream
 entries, this says what side effects the operation should have.
NB: Things that are either unusual about this opcode or that I thought worth
 noting in particular.

See http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf
 for how these things ought to work, ideally. This document tries to describe
 how things work in there Tamarin, even if they are incorrect.
 This file is based on my best understanding, and there is no warranty of
 correctness or any other kind.

Hex: 0x01
Name: OP_bkpt
Do: Enter the debugger if one has been invoked.

Hex: 0x02
Name: OP_nop
Do: Nothing.

Hex: 0x03
Name: OP_throw
Stack In:
 obj -- an object
Stack Out:
 .
Do: Throw obj as an exception

Hex: 0x04
Name: OP_getsuper
Stream:
 name_id -- V32 index to multiname 'name'
Stack In:
 obj -- an object
 [ns [n]] -- Namespace stuff.
Stack Out:
 super -- if obj.name is a method, the super of that method.
       -- if obj.name is write-only data, throw ReferenceError.
       -- if obj.name is readable, the return of the getter of super.

Hex: 0x05
Name: OP_setsuper
Stream: UV32 index to multiname 'name'
Stack In:
 obj -- an object
 val -- an object
 [ns [n]] -- Namespace stuff.
Stack Out:
 .
Do: Make val the super of obj.name ; throw ReferenceError if obj.name is
 not writable.

Hex: 0x06
Name: OP_dxns (Dynamically eXtend Name Space?)
Stream: UV32 index to string pool 'nsname'
Do: Create a new public namespace with name nsname, enter the namespace.

Hex: 0x07
Name: OP_dxnslate (Dynamically eXtend Name Space late?)
Stack In:
 nsname -- a string object
Stack Out:
 .
Do: Create a new public namespace with name nsname, but don't enter it.

Hex: 0x08
Name: OP_kill
Stream: UV32 frame pointer offset 'offset'
Frame: 
 Kill at offset

Hex: 0x09
Name: OP_label
Do: Unknown purpose, Tamarin does nothing.

Hex: 0x0A
Name: UNUSED

Hex: 0x0B
Name: UNUSED

Hex: 0x0C
Name: OP_ifnlt
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If !(a < b) move by jump in stream, as OP_jump does.

Hex: 0x0D
Name: OP_ifnle
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If !(a <= b) move by jump in stream, as OP_jump does.

Hex: 0x0E
Name: OP_ifngt
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If !(a > b) move by jump in stream, as OP_jump does.

Hex: 0x0F
Name: OP_ifnge
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If !(a >= b) move by jump in stream, as OP_jump does.

Hex: 0x10
Name: OP_jump
Stream: S24 jump offset 'jump'
Do: If jump is negative, check for interrupts. Move by jump in stream.

Hex: 0x11
Name: OP_iftrue
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
Stack Out:
 .
Do: If a has a 'true' value, move by jump in stream, as OP_jump does.

Hex: 0x12
Name: OP_iffalse
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
Stack Out:
 .
Do: If a has a 'false' value, move by jump in stream, as OP_jump does.

Hex: 0x13
Name: OP_ifeq
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a == b (weakly), move by jump in stream, as OP_jump does.

Hex: 0x14
Name: OP_ifne
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a != b (weakly), move by jump in stream, as OP_jump does.

Hex: 0x15
Name: OP_iflt
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a < b move by jump in stream, as OP_jump does.

Hex: 0x16
Name: OP_ifle
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a <= b move by jump in stream, as OP_jump does.

Hex: 0x17
Name: OP_ifgt
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a > b move by jump in stream, as OP_jump does.

Hex: 0x18
Name: OP_ifge
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a >= b move by jump in stream, as OP_jump does.

Hex: 0x19
Name: OP_ifstricteq
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a == b (strictly), move by jump in stream, as OP_jump does.

Hex: 0x1A
Name: OP_ifstrictne
Stream: S24 jump offset 'jump'
Stack In:
 a -- an object
 b -- an object
Stack Out:
 .
Do: If a != b (strongly), move by jump in stream, as OP_jump does.

Hex: 0x1B
Name: OP_lookupswitch
Stream: 3 bytes unknown use | V32 count as 'case_count - 1' | case_count of S24
 as 'cases'
Stack In:
 index -- an integer object
Stack Out:
 .
Do: If index >= case_count, reset stream pointer to position on op entry.
 Otherwise, move by cases[index] - 1 from stream position on op entry.

Hex: 0x1C
Name: OP_pushwith
Stack In:
 scope -- a scope
Stack Out:
 .
Do: Enter scope with previous scope as its base, unless it already had a base,
 in which case leave that alone.

Hex: 0x1D
Name: OP_popscope
Do: Leave current scope. Clear the base if the depth is now shallower than the
 base's depth.

Hex: 0x1E
Name: OP_nextname
Stack In:
 obj -- an object
 index -- an integer object
Stack Out:
 name -- the key name at index in obj (not next after index).
Do: If obj is a namespace index 1 is the uri of the namespace, index 2 is
 the prefix of the namespace, and any other value is a null string object. If
 obj is an immutable object, like a number, operate on its prototype instead.
 If there is no such index, name is null.

Hex: 0x1F
Name: OP_hasnext
Stack In:
 obj -- an object
 index -- an integer object
Stack Out:
 next_index -- a raw integer of the next index after index in obj, or 0 if none.
Do: If there is a key value pair after the one at index, make next_index as it.
 Otherwise, make next_index 0.

Hex: 0x20
Name: OP_pushnull
Stack Out:
 n -- a Null object.

Hex: 0x21
Name: OP_pushundefined
 n -- an Undefined object.

Hex: 0x22
Name: UNUSED

Hex: 0x23
Name: OP_nextvalue
Stack In:
 obj -- an object (namespaces okay)
 index -- an integer object
Stack Out:
 value -- the value of the key value pair in obj at index.

Hex: 0x24
Name: OP_pushbyte
Stream: S8 as 'byte'
Stack Out:
 byte -- as a raw byte

Hex: 0x25
Name: OP_pushshort
Stream: V32 as 'value'
Stack Out:
 value -- as a raw integer

Hex: 0x26
Name: OP_pushtrue
Stack Out:
 true -- the True object

Hex: 0x27
Name: OP_pushfalse
Stack Out:
 false -- the False object

Hex: 0x28
Name: OP_pushnan
Stack Out:
 NaN -- the NaN object

Hex: 0x29
Name: OP_pop
Stack In:
 a -- anything
Stack Out:
 .

Hex: 0x2A
Name: OP_dup
Stack In:
 a -- anything
Stack Out:
 a
 a

Hex: 0x2B
Name: OP_swap
Stack In:
 a -- anything
 b -- anything
Stack Out:
 b
 a

Hex: 0x2C
Name: OP_pushstring
Stream: V32 string pool index 'index'
Stack Out:
 value -- String object from string_pool[index]

Hex: 0x2D
Name: OP_pushint
Stream: V32 int pool index 'index'
Stack Out:
 value -- Integer object from integer_pool[index]

Hex: 0x2E
Name: OP_pushuint
Stream: V32 uint pool index 'index'
Stack Out:
 value -- Unsigned Integer object from unsigned_integer_pool[index]

Hex: 0x2F
Name: OP_pushdouble
Stream: V32 double pool index 'index'
Stack Out:
 value -- Double object from double_pool[index]

Hex: 0x30
Name: OP_pushscope
Stack In:
 scope -- a scope
Stack Out:
 .
Do: Enter scope without altering base.

Hex: 0x31
Name: OP_pushnamespace
Stream: V32 namespace pool index 'index'
Stack Out:
 ns -- Namespace object from namespace_pool[index]

Hex: 0x32
Name: OP_hasnext2
Stream: V32 frame location 'objloc' | V32 frame location 'indexloc'
Stack Out:
 truth -- True if frame[objloc] has a key/value pair after frame[indexloc],
  following delagates (__proto__) objects if needed. False, otherwise.
Frame:
 Change at objloc to object which possessed next value.
 Change at indexloc to index (as object) of the next value.

Hex: 0x33
Name: UNUSED

Hex: 0x34
Name: UNUSED

Hex: 0x35
Name: UNUSED

Hex: 0x36
Name: UNUSED

Hex: 0x37
Name: UNUSED

Hex: 0x38
Name: UNUSED

Hex: 0x39
Name: UNUSED

Hex: 0x3A
Name: UNUSED

Hex: 0x3B
Name: UNUSED

Hex: 0x3C
Name: UNUSED

Hex: 0x3D
Name: UNUSED

Hex: 0x3E
Name: UNUSED

Hex: 0x3F
Name: UNUSED

Hex: 0x40
Name: OP_newfunction
Stream: V32 'index'
Stack Out:
 func -- the function object
Do: Information about the function is in the pool at index. Construct the
 function from this information, the current scope, and the base of the scope.

Hex: 0x41
Name: OP_call
Stream: V32 'arg_count'
Stack In:
 func -- the function to be called
 obj -- the object to which the function belongs
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the value returned by obj->func(arg1, ...., argN)

Hex: 0x42
Name: OP_construct
Stream: V32 'arg_count'
Stack In:
 obj -- the object to be constructed
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- obj after it has been constructed as obj(arg1, ..., argN)

Hex: 0x43
Name: OP_callmethod
Stream: V32 'method_id + 1' | V32 'arg_count'
Stack In:
 obj -- the object to be called
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the value returned by obj::'method_id'(arg1, ..., argN)

Hex: 0x44
Name: OP_callstatic
Stream: V32 'method_id' | V32 'arg_count'
Stack In:
 obj -- the object to act as a receiver for the static call
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the value returned by obj->ABC::'method_id'(arg1, ..., argN)

Hex: 0x45
Name: OP_callsuper
Stream: V32 'name_offset' | V32 'arg_count'
Stack In:
 obj -- the object whose super is to be called
 [ns [n]] -- Namespace stuff
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the value returned by obj::(resolve)'name_offset'::super(arg1,
  ..., argN)

Hex: 0x46
Name: OP_callproperty
Stream: V32 'name_offset' | V32 'arg_count'
Stack In:
 obj -- The object whose property is to be accessed.
 [ns [n]] -- Namespace stuff
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the value returned by obj::(resolve)'name_offset'(arg1, ..., argN)
NB: Calls getter/setter if they exist.

Hex: 0x47
Name: OP_returnvoid
Do: Return an Undefined object up the callstack.

Hex: 0x48
Name: OP_returnvalue
Stack In:
 value -- value to be returned
Stack Out:
 .
Do: Return value up the callstack.

Hex: 0x49
Name: OP_constructsuper
Stream: V32 'arg_count'
Stack In:
 obj -- the object whose super's constructor should be invoked
 arg1 ... argN -- the arg_count arguments
Stack Out:
 value -- obj after obj::super(arg1, ..., argN) has been invoked

Hex: 0x4A
Name: OP_constructprop
Stream: V32 'name_offset' | V32 'arg_count'
Stack In:
 obj -- the object whose property should be constructed
 [ns [n]] -- Namespace stuff
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the newly constructed prop from obj::(resolve)'name_offset'(arg1,
  ..., argN)

Hex: 0x4B
Name: OP_callsuperid
Do: Nothing, this is an intermediate code op, should not appear in ABC.

Hex: 0x4C
Name: OP_callproplex
Stream: V32 'name_offset' | V32 'arg_count'
Stack In:
 obj -- The object whose property is to be accessed.
 [ns [n]] -- Namespace stuff
 arg1 ... argN -- the arg_count arguments to pass
Stack Out:
 value -- the value returned by obj::(resolve)'name_offset'(arg1, ..., argN)
NB: As nearly as I can tell, this does _not_ call getter/setter if they exist,
 but is otherwise identical to OP_callproperty

Hex: 0x4D
Name: OP_callinterface
Do: Nothing, this is an intermediate code op, should not appear in ABC.

Hex: 0x4E
Name: OP_callsupervoid
See: 0x45 (OP_callsuper), but
Stack Out:
 .

Hex: 0x4F
Name: OP_callpropvoid
See: 0x46 (OP_callproperty), but
Stack Out:
 .

Hex: 0x50
Name: UNUSED

Hex: 0x51
Name: UNUSED

Hex: 0x52
Name: UNUSED

Hex: 0x53
Name: UNUSED

Hex: 0x54
Name: UNUSED

Hex: 0x55
Name: OP_newobject
Stream: V32 'arg_count'
Stack In:
 prop_name_1 -- a string
 prop_value_1 -- a value object
 .
 . (arg_count name/value pairs in all)
 .
 prop_name_n -- a string
 prop_value_n -- a value object
Stack Out:
 obj -- A new object which contains all of the given properties.
NB: This builds an object from its properties, it's not a constructor.

Hex: 0x56
Name: OP_newarray
Stream: V32 'array_size'
Stack In:
 value_1 -- a value
 .
 . (array_size of these)
 .
 value_n -- a value
Stack Out:
 array -- an array { value_1, value_2, ..., value_n }

Hex: 0x57
Name: OP_newactivation
Stack Out:
 vtable -- A new virtual table, which has the previous one as a parent.

Hex: 0x58
Name: OP_newclass
Stream: V32 'class_id'
Stack In:
 obj -- An object to be turned into a class
Stack Out:
 class -- The newly made class, made from obj and the information at
  cinits_pool[class_id]
NB: This depends on scope and scope base (to determine base class)

Hex: 0x59
Name: OP_getdescendants
Stream: V32 'name_id'
Stack In:
 value -- Whose descendants to get
 [ns [n]] -- Namespace stuff
Stack Out:
 ?
NB: This op seems to always throw a TypeError in Tamarin, though I assume that
 it ought to do something to yield a list of descendants of a class.

Hex: 0x5A
Name: OP_newcatch
Stream: V32 'catch_id'
Stack Out:
 vtable -- A new vtable suitable to catch an exception of the type in catch_id.
NB: Need more information on how exceptions are set up.

Hex: 0x5B
Name: UNUSED

Hex: 0x5C
Name: UNUSED

Hex: 0x5D
Name: OP_findpropstrict
Stream: V32 'name_id'
Stack In:
 [ns [n]] -- Namespace stuff
Stack Out:
 owner -- The object which owns the property given by looking up the name_id,
  or throw a ReferenceError if none exists.

Hex: 0x5E
Name: OP_findproperty
Stream: V32 'name_id'
Stack In:
 [ns [n]] -- Namespace stuff
Stack Out:
 owner -- The object which owns the property given by looking up the name_id,
  or an Undefined object if none exists.

Hex: 0x5F
Name: OP_finddef
Stream: V32 'name_id' (no ns expansion)
Stack Out:
 def -- The definition of the name at name_id.

Hex: 0x60
Name: OP_getlex
Stream: V32 'name_id' (no ns expansion)
Stack Out:
 property -- The result of 0x5D (OP_findpropstrict) + 0x66 (OP_getproperty)

Hex: 0x61
Name: OP_setproperty
Stream: V32 'name_id'
Stack In:
 obj -- The object whose property is to be set
 [ns [n]] -- Namespace stuff
 [key] -- Key name for the property. Will not have both Namespace and key.
 value -- The value to be used
Stack Out:
 .
Do: Set obj::(resolve)'name_id' to value, or set obj::key to value.
NB: I'm not yet clear which should be used when. (Chad)

Hex: 0x62
Name: OP_getlocal
Stream: V32 'frame_index'
Frame: value at frame_index is needed
Stack Out:
 value

Hex: 0x63
Name: OP_setlocal
Stream: V32 'frame_index'
Frame: obj at frame_index is set to value
Stack In:
 value
Stack Out:
 .

Hex: 0x64
Name: OP_getglobalscope
Stack Out:
 global -- The global scope object

Hex: 0x65
Name: OP_getscopeobject
Stream: S8 'depth'
Stack Out:
 scope -- The scope object at depth

Hex: 0x66
Name: OP_getproperty
Stream: V32 'name_id'
Stack In:
 obj -- The object whose property is to be retrieved
 [ns [n]] -- Namespace stuff
 [key] -- Key name for the property. Will not have both Namespace and key.
Stack Out:
 prop -- The requested property.
NB: As with 0x61 (OP_setproperty) it's unclear to me when key gets used and
 when the namespace (or nothing) is used.

Hex: 0x67
Name: UNUSED

Hex: 0x68
Name: OP_initproperty
Stream V32 'name_id'
Stack In:
 obj -- The object whose property is to be initialized
 [ns [n]] -- Namespace stuff
 value -- The value to be put into the property.
Stack Out:
 .
Do:
 Set obj::(resolve)'name_id' to value, and set the bindings from the context.

Hex: 0x69
Name: UNUSED

Hex: 0x6A
Name: OP_deleteproperty
Stream: V32 'name_id'
Stack In:
 obj -- The object whose property should be deleted.
 [ns [n]] -- Namespace stuff
Stack Out:
 truth -- True if the property was deleted or did not exist, otherwise False.

Hex: 0x6B
Name: UNUSED

Hex: 0x6C
Name: OP_getslot
Stream: V32 'slot_index + 1'
Stack In:
 obj -- The object which owns the desired slot.
Stack Out:
 slot -- obj.slots[slot_index]

Hex: 0x6D
Name: OP_setslot
Stream: V32 'slot_index + 1'
Stack In:
 obj -- The object whose slot should be set.
 value -- The value intended for the slot.
Stack Out:
 .
Do: obj.slots[slot_index] = value

Hex: 0x6E
Name: OP_getglobalslot
Stream: V32 'slot_index + 1'
Stack In:
 .
Stack Out:
 slot -- globals.slots[slot_index]
NB: Deprecated

Hex: 0x6F
Name: OP_setglobalslot
Stream: V32 'slot_index + 1'
Stack In:
 value -- The value to be placed into the slot.
Stack Out:
 .
Do: globals[slot_index] = value
NB: Deprecated

Hex: 0x70
Name: OP_convert_s
Stack In:
 value -- An object
Stack Out:
 str_value -- value as a string

Hex: 0x71
Name: OP_esc_xelem
Stack In:
 value -- An object to be escaped
Stack Out:
 str_value -- value as a string, escaped suitably to be put in an XML element.

Hex: 0x72
Name: OP_esc_xattr
Stack In:
 value -- An object to be escaped
Stack Out:
 str_value -- value as a string, escaped suitably to be put in an XML attribute.

Hex: 0x73
Name: OP_convert_i
Stack In:
 value -- An object to be converted to Integer
Stack Out:
 int_value -- value as an integer object

Hex: 0x74
Name: OP_convert_u
Stack In:
 value -- An object to be converted to unsigned integer
Stack Out:
 int_value -- value as an unsigned integer object

Hex: 0x75
Name: OP_convert_d
Stack In:
 value -- An object to be converted to a double
Stack Out:
 double_value -- value as a double object

Hex: 0x76
Name: OP_convert_b
Stack In:
 value -- An object to be converted to a boolean
Stack Out:
 bool_value -- value as a boolean object

Hex: 0x77
Name: OP_convert_o
Stack In:
 obj -- An object
Stack Out:
 obj -- An object
Do: If obj is Undefined or Null, throw TypeError

Hex: 0x78
Name: OP_checkfilter
Stack In:
 obj -- An object
Stack Out:
 obj -- An object
Do: If obj is not XML based, throw TypeError

Hex: 0x79
Name: UNUSED

Hex: 0x7A
Name: UNUSED

Hex: 0x7B
Name: UNUSED

Hex: 0x7C
Name: UNUSED

Hex: 0x7D
Name: UNUSED

Hex: 0x7E
Name: UNUSED

Hex: 0x7F
Name: UNUSED

Hex: 0x80
Name: OP_coerce
Stream: V32 'name_index'
Stack In:
 obj -- An object to be converted
Stack Out:
 coerced_obj -- The object as the desired (resolve)'name_index' type.

Hex: 0x81
Name: OP_coerce_b
See: 0x76 (OP_convert_b)
NB: Deprecated

Hex: 0x82
Name: OP_coerce_a
Stack In:
 obj -- An object to be converted
Stack Out:
 obj
Do: Nothing. (The 'a' is for atom, and this already is.)

Hex: 0x83
Name: OP_coerce_i
See: 0x73 OP_convert_i
NB: Deprecated

Hex: 0x84
Name: OP_coerce_d
See: 0x75 OP_convert_d
NB: Deprecated

Hex: 0x85
Name: OP_coerce_s
Stack In:
 obj -- An object to be converted
Stack Out:
 str_obj -- The converted object. nullString object if obj is Null or Undefined

Hex: 0x86
Name: OP_astype
Stream: V32 'name_index' (no namespace)
Stack In:
 obj -- An object to be checked
Stack Out:
 cobj -- obj if obj is of type (resolve)'name_index', otherwise Null

Hex: 0x87
Name: OP_astypelate
Stack In:
 obj -- An object to be checked
 valid -- The object whose type is to be matched
Stack Out:
 cobj -- obj if type of obj is type of valid, otherwise Null

Hex: 0x88
Name: OP_coerce_u
See: 0x74 (OP_convert_u)
NB: Deprecated

Hex: 0x89
Name: OP_coerce_o
Stack In:
 obj -- An object
Stack Out:
 cobj -- obj if obj is not Undefined, otherwise Null

Hex: 0x8A
Name: UNUSED

Hex: 0x8B
Name: UNUSED

Hex: 0x8C
Name: UNUSED

Hex: 0x8D
Name: UNUSED

Hex: 0x8E
Name: UNUSED

Hex: 0x8F
Name: UNUSED

Hex: 0x90
Name: OP_negate
Stack In:
 obj -- An object
Stack Out:
 negdouble -- -1.0 * (double) obj

Hex: 0x91
Name: OP_increment
Stack In:
 num -- A number, integer or double
Stack Out:
 num2 -- The same value, but new object.
Do:
 num = num + 1 (post-increment)

Hex: 0x92
Name: OP_inclocal
Stream: V32 'frame_addr'
Frame: Load i from frame_addr. Store clone(i) at frame_addr. i = i + 1
 (post-increment in frame)

Hex: 0x93
Name: OP_decrement
Stack In:
 num -- A number, integer or double
Stack Out:
 num2 -- The same value, but new object.
Do:
 num = num - 1 (post-decrement)

Hex: 0x94
Name: OP_declocal
Stream: V32 'frame_addr'
Frame: Load i from frame_addr. Store clone(i) at frame_addr. i = i - 1
 (post-decrement in frame)

Hex: 0x95
Name: OP_typeof
Stack In:
 obj -- An object
Stack Out:
 type -- typeof(obj)

Hex: 0x96
Name: OP_not
Stack In:
 obj -- An object
Stack Out:
 nobj -- A truth object with value !((Boolean) obj)

Hex: 0x97
Name: OP_bitnot
Stack In:
 obj -- An object
Stack Out:
 nint -- ~((Int) obj)

Hex: 0x98
Name: UNUSED

Hex: 0x99
Name: UNUSED

Hex: 0x9A
Name: OP_concat
NB: It is an error for this to appear.

Hex: 0x9B
Name: OP_add_d
NB: It is an error for this to appear.

Hex: 0x9C
Name: UNUSED

Hex: 0x9D
Name: UNUSED

Hex: 0x9E
Name: UNUSED

Hex: 0x9F
Name: UNUSED

Hex: 0xA0
Name: OP_add
Stack In:
 a
 b
Stack Out:
 a + b (double if numeric)

Hex: 0xA1
Name: OP_subtract
Stack In:
 a
 b
Stack Out:
 a - b (double)

Hex: 0xA2
Name: OP_multiply
Stack In:
 a
 b
Stack Out:
 a * b (double)

Hex: 0xA3
Name: OP_divide
Stack In:
 a
 b
Stack Out:
 a / b (double)

Hex: 0xA4
Name: OP_modulo
Stack In:
 a
 b
Stack Out:
 a % b

Hex: 0xA5
Name: OP_lshift
Stack In:
 a
 b
Stack Out:
 a << b

Hex: 0xA6
Name: OP_rshift
Stack In:
 a
 b
Stack Out:
 a >> b

Hex: 0xA7
Name: OP_urshift
Stack In:
 a
 b
Stack Out:
 ((unsigned) a) >> b

Hex: 0xA8
Name: OP_bitand
Stack In:
 a
 b
Stack Out:
 a & b

Hex: 0xA9
Name: OP_bitor
Stack In:
 a
 b
Stack Out:
 a | b

Hex: 0xAA
Name: OP_bitxor
Stack In:
 a
 b
Stack Out:
 a ^ b

Hex: 0xAB
Name: OP_equals
Stack In:
 a
 b
Stack Out:
 truth -- Truth of (a == b) (weakly)

Hex: 0xAC
Name: OP_strictequals
Stack In:
 a
 b
Stack Out:
 truth -- Truth of (a == b) (strongly, as in 0x19 (OP_ifstricteq))

Hex: 0xAD
Name: OP_lessthan
Stack In:
 a
 b
Stack Out:
 truth -- Truth of (a < b)

Hex: 0xAE
Name: OP_lessequals
Stack In:
 a
 b
Stack Out:
 truth -- Truth of (a <= b)

Hex: 0xAF
Name: OP_greaterthan
Stack In:
 a
 b
Stack Out:
 truth -- Truth of (a > b)

Hex: 0xB0
Name: OP_greaterequals
Stack In:
 a
 b
Stack Out:
 truth -- Truth of (a >= b)

Hex: 0xB1
Name: OP_instanceof
Stack In:
 val -- An object
 super -- An object
Stack Out:
 truth -- Truth of "val is an instance of super"

Hex: 0xB2
Name: OP_istype
Stream: V32 'name_id'
Stack In:
 obj -- An object
Stack Out:
 truth -- Truth of "obj is of the type given in (resolve)'name_id'"

Hex: 0xB3
Name: OP_istypelate
Stack In:
 obj -- An object
 type -- A type to match
Stack Out:
 truth -- Truth of "obj is of type"

Hex: 0xB4
Name: OP_in
Stack In:
 name -- The name to find
 obj -- The object to search for it
Stack Out:
 truth -- True if name is in the current namespace or anywhere in object.
  Don't look in the namespace if obj is a dictionary.

Hex: 0xB5
Name: UNUSED

Hex: 0xB6
Name: UNUSED

Hex: 0xB7
Name: UNUSED

Hex: 0xB8
Name: UNUSED

Hex: 0xB9
Name: UNUSED

Hex: 0xBA
Name: UNUSED

Hex: 0xBB
Name: UNUSED

Hex: 0xBC
Name: UNUSED

Hex: 0xBD
Name: UNUSED

Hex: 0xBE
Name: UNUSED

Hex: 0xBF
Name: UNUSED

Hex: 0xC0
Name: OP_increment_i
See: 0x91 (OP_increment), but forces types to int, not double

Hex: 0xC1
Name: OP_decrement_i
See: 0x93 (OP_decrement), but forces types to int, not double

Hex: 0xC2
Name: OP_inclocal_i
See: 0x92 (OP_inclocal), but forces types to int, not double

Hex: 0xC3
Name: OP_declocal_i
See: 0x94 (OP_declocal), but forces types to int, not double

Hex: 0xC4
Name: OP_negate_i
See: 0x90 (OP_negate), but forces type to int, not double

Hex: 0xC5
Name: OP_add_i
See: 0xA0 (OP_add), but forces type to int

Hex: 0xC6
Name: OP_subtract_i
See: 0xA1 (OP_subtract), but forces type to int

Hex: 0xC7
Name: OP_multiply_i
See: 0xA2 (OP_multiply), but forces type to int

Hex: 0xC8
Name: UNUSED

Hex: 0xC9
Name: UNUSED

Hex: 0xCA
Name: UNUSED

Hex: 0xCB
Name: UNUSED

Hex: 0xCC
Name: UNUSED

Hex: 0xCD
Name: UNUSED

Hex: 0xCE
Name: UNUSED

Hex: 0xCF
Name: UNUSED

Hex: 0xD0
Name: OP_getlocal0
Frame: Load frame[0] as val
Stack Out:
 val

Hex: 0xD1
Name: OP_getlocal1
Frame: Load frame[1] as val
Stack Out:
 val

Hex: 0xD2
Name: OP_getlocal2
Frame: Load frame[2] as val
Stack Out:
 val

Hex: 0xD3
Name: OP_getlocal3
Frame: Load frame[3] as val
Stack Out:
 val

Hex: 0xD4
Name: OP_setlocal0
Frame: Store val as frame[0]
Stack In:
 val
Stack Out:
 .

Hex: 0xD5
Name: OP_setlocal1
Frame: Store val as frame[1]
Stack In:
 val
Stack Out:
 .

Hex: 0xD6
Name: OP_setlocal2
Frame: Store val as frame[2]
Stack In:
 val
Stack Out:
 .

Hex: 0xD7
Name: OP_setlocal3
Frame: Store val as frame[3]
Stack In:
 val
Stack Out:
 .

Hex: 0xD8
Name: UNUSED

Hex: 0xD9
Name: UNUSED

Hex: 0xDA
Name: UNUSED

Hex: 0xDB
Name: UNUSED

Hex: 0xDC
Name: UNUSED

Hex: 0xDD
Name: UNUSED

Hex: 0xDE
Name: UNUSED

Hex: 0xDF
Name: UNUSED

Hex: 0xE0
Name: UNUSED

Hex: 0xE1
Name: UNUSED

Hex: 0xE2
Name: UNUSED

Hex: 0xE3
Name: UNUSED

Hex: 0xE4
Name: UNUSED

Hex: 0xE5
Name: UNUSED

Hex: 0xE6
Name: UNUSED

Hex: 0xE7
Name: UNUSED

Hex: 0xE8
Name: UNUSED

Hex: 0xE9
Name: UNUSED

Hex: 0xEA
Name: UNUSED

Hex: 0xEB
Name: UNUSED

Hex: 0xEC
Name: UNUSED

Hex: 0xED
Name: UNUSED

Hex: 0xEE
Name: OP_abs_jump
NB: It is an error for this to appear.

Hex: 0xEF
Name: OP_debug
Stream: 7 bytes of unknown stuff to be skipped
Do: skip ahead 7 bytes in stream

Hex: 0xF0
Name: OP_debugline
Stream: V32 'line_number'
Do: Nothing, but line_number is for the debugger if wanted.

Hex: 0xF1
Name: OP_debugfile
Stream: V32 'name_offset'
Do: Nothing, but 'name_offset' into string pool is the file name if wanted.

Hex: 0xF2
Name: OP_bkptline
Stream: V32 'line_number'
Do: Enter debugger if present, line_number is the line number in source.

Hex: 0xF3
Name: OP_timestamp
Do: Nothing.

Hex: 0xF4
Name: UNUSED

Hex: 0xF5
Name: OP_verifypass
NB: It seems an error for this to appear.

Hex: 0xF6
Name: OP_alloc
NB: Error to appear in ABC

Hex: 0xF7
Name: OP_mark
NB: Error to appear in ABC

Hex: 0xF8
Name: OP_wb
NB: Error to appear in ABC

Hex: 0xF9
Name: OP_prologue
NB: Error to appear in ABC

Hex: 0xFA
Name: OP_sendenter
NB: Error to appear in ABC

Hex: 0xFB
Name: OP_doubletoatom
NB: Error to appear in ABC

Hex: 0xFC
Name: OP_sweep
NB: Error to appear in ABC

Hex: 0xFD
Name: OP_codegenop
NB: Error to appear in ABC

Hex: 0xFE
Name: OP_verifyop
NB: Error to appear in ABC

Hex: 0xFF
Name: OP_decode
NB: Error to appear in ABC
~                                                                                                                                                                                                              
~                                                                                                                                                                                                            
